{"version":3,"sources":["GameState.ts","AbstractPyramidSolitaire.ts","Suit.ts","Card.ts","AbstractSinglePyramidSolitaireModel.ts","BasicPyramidSolitaire.ts","Pos2D.ts","ViewCard.ts","PyramidSolitaireVisualView.ts","PyramidSolitaireVisualController.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["GameState","Suit","AbstractPyramidSolitaire","pyramid","stock","draws","gamestate","removalValue","this","NOT_STARTED","deck","shuffle","numRows","numDraw","isValidDeck","Error","isEnoughCards","length","deckCopy","Array","forEach","value","push","dealCards","drawIndex","shift","STARTED","row1","card1","row2","card2","removeTwoChecks","isCovered","row","card","checkStarted","isRowInBounds","isCardInBounds","getCardAt","getValue","discardDraw","isGameWon","uncovered","getUncovered","canBeRemoved","canAddToRemovalValue","getNumDraw","result","col","drawsCopy","cards","index","Card","suit","obj","that","toString","BasicPyramidSolitaire","rowCopy","suits","HEART","SPADE","CLUB","DIAMOND","x","rowIndex","jindex","equals","getDeck","deckSize","numDraws","array","temporaryValue","randomIndex","currentIndex","Math","floor","random","Pos2D","y","ViewCard","screenPos","pyramidPos","label","isDrawCard","selected","visible","CARD_WIDTH","CARD_HEIGHT","context","font","fillStyle","fillRect","getX","getY","strokeRect","fillText","redSuit","pyramidPosition","getLabel","substring","type","localeCompare","PyramidSolitaireVisualView","canvas","removeButton","rulesButton","controller","drawsSelected","score","manager","ctx","getContext","addEventListener","mouseListener","bind","removeButtonActionListener","rulesButtonActionListener","render","getPyramidPosition","isDrawCardCheck","setVisible","setSelected","removedDraw","newDrawCards","drawCards","getDrawCards","removedCard","replacementCard","setLabel","setPyramidPosition","indexOf","getMatchingCard","cardPositions","posIndex","message","e","selectCard","pageX","pageY","refresh","removeSelected","getSelectedCards","resetSelected","alert","pyramidPositions","getSelected","getScreenPosition","notCovered","getVisible","botLeft","botRight","viewCard","PyramidSolitaireVisualController","view","model","startGame","console","log","getPyramid","beginInteraction","drawCard","createPyramidViewCard","createDrawViewCard","updateScore","getScore","validCards","containsDrawCard","removeWithDraw","removeWithoutDraw","makeInvisible","deselect","pyramidHeight","xOffset","positions","drawCardsCount","updateDraws","nonDrawCard","removeUsingDraw","remove","removeTwo","App","document","getElementById","playGame","rulesAndShuffleButtonStyle","marginTop","marginLeft","backgroundColor","color","fontSize","fontFamily","id","style","onClick","reshuffle","width","height","border","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.bdb5a633.chunk.js","sourcesContent":["/**\r\n * Represents the state of a game as one of the following based on whether or not the game has\r\n * begun. Represented as one of:\r\n * <ul>\r\n *   <li>NOT-STARTED</li>\r\n *   <li>STARTED</li>\r\n * </ul>\r\n */\r\nexport enum GameState {\r\n    NOT_STARTED = \"Not Started\",\r\n    STARTED = \"Started\"\r\n}","import {Card} from \"./Card\";\r\nimport {GameState} from \"./GameState\";\r\n\r\n/**\r\n * Represents the abstract functionality for a game of PyramidSolitaire, regardless of the number of\r\n * pyramids of the game.\r\n */\r\n export abstract class AbstractPyramidSolitaire {\r\n    protected pyramid: Array<Array<Card>>;\r\n    private stock: Array<Card>;\r\n    protected draws: Array<Card>;\r\n    protected gamestate: GameState;\r\n    protected removalValue: number = 13;\r\n\r\n    /**\r\n     * Constructs a {@code AbstractPyramidModel} object.\r\n     */\r\n    constructor() {\r\n        this.gamestate = GameState.NOT_STARTED;\r\n    }\r\n\r\n    /**\r\n     * Return a valid and complete deck of cards for a game of Pyramid Solitaire. There is no\r\n     * restriction imposed on the ordering of these cards in the deck. The validity of the deck is\r\n     * determined by the rules of the specific game in the classes implementing this interface.\r\n     *\r\n     * @return the deck of cards as a list\r\n     */\r\n    abstract getDeck(): Array<Card>;\r\n\r\n    /**\r\n     * <p>Deal a new game of Pyramid Solitaire.\r\n     * The cards to be used and their order are specified by the the given deck, unless the {@code\r\n     * shuffle} parameter indicates the order should be ignored.</p>\r\n     *\r\n     * <p>This method first verifies that the deck is valid. It deals cards in rows\r\n     * (left-to-right, top-to-bottom) into the characteristic pyramid shape with the specified number\r\n     * of rows, followed by the specified number of draw cards. When {@code shuffle} is {@code false},\r\n     * the 0th card in {@code deck} is used as the first card dealt.</p>\r\n     *\r\n     * <p>This method should have no other side effects, and should work for any valid arguments.</p>\r\n     *\r\n     * @param deck    the deck to be dealt\r\n     * @param shuffle if {@code false}, use the order as given by {@code deck}, otherwise use a\r\n     *                randomly shuffled order\r\n     * @param numRows number of rows in the pyramid\r\n     * @param numDraw number of draw cards available at a time\r\n     * @throws Error if the deck is null or invalid, the number of pyramid rows or\r\n     *                                  number of available draw cards is non-positive, or a full\r\n     *                                  pyramid and draw pile cannot be dealt with the number of given\r\n     *                                  cards in deck\r\n     */\r\n    startGame(deck: Array<Card>, shuffle: boolean, numRows: number, numDraw: number): void {\r\n\r\n        //Checks that the given deck is not null or invalid.\r\n        if (deck == null || !this.isValidDeck(deck)) {\r\n            throw new Error(\"The deck cannot be null.\");\r\n        }\r\n\r\n        // Checks if a pyramid of the given size and draw pile of the given size\r\n        // are possible with the size of the given deck.\r\n        if (!this.isEnoughCards(deck.length, numRows, numDraw)) {\r\n            throw new Error(\"Not enough cards in this deck for this deal.\");\r\n        }\r\n\r\n        // Checks if the number of rows or draws is 0, errors if so.\r\n        if (numRows == 0 && numDraw == 0) {\r\n            throw new Error(\"Rows and draws cannot be zero.\");\r\n        }\r\n\r\n        //Checks that the given number of rows is non-negative.\r\n        if (numRows <= 0) {\r\n            throw new Error(\"Number of rows cannot be negative or zero.\");\r\n        }\r\n\r\n        //Checks that the given number of draw cards is non-negative.\r\n        if (numDraw < 0) {\r\n            throw new Error(\"Number of draw cards cannot be negative.\");\r\n        }\r\n        // Copies the deck over to a temp so that it will not be altered.\r\n        let deckCopy: Array<Card> = new Array<Card>();\r\n\r\n        deck.forEach(function (value) {\r\n            deckCopy.push(value);\r\n        });\r\n\r\n        this.pyramid = this.dealCards(numRows, deckCopy, shuffle);\r\n        this.draws = new Array<Card>();\r\n        for (let drawIndex = 0; drawIndex < numDraw; drawIndex++) {\r\n            this.draws.push(deckCopy[0]);\r\n            deckCopy.shift();\r\n        }\r\n        this.stock = deckCopy;\r\n        this.gamestate = GameState.STARTED;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of lists of cards to represent the pyramid for the {@code BasicPyramidSolitaire}\r\n     * class.\r\n     *\r\n     * @param numRows the height of the pyramid to be created\r\n     * @param deck    the cards to be used for creating the pyramid\r\n     * @param shuffle indicates whether or not the user want's the deck to be shuffled\r\n     * @return a list of list of cards representing a pyramid for this game\r\n     */\r\n    protected abstract dealCards(numRows: number, deck: Array<Card>, shuffle: boolean): Array<Array<Card>>;\r\n\r\n\r\n\r\n    /**\r\n     * Execute a two-card move on the pyramid, using the two specified card positions.\r\n     *\r\n     * @param row1  row of first card position, numbered from 0 from the top of the pyramid\r\n     * @param card1 card of first card position, numbered from 0 from left\r\n     * @param row2  row of second card position\r\n     * @param card2 card of second card position\r\n     * @throws Error if the move is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    removeTwo(row1: number, card1: number, row2: number, card2: number) : void {\r\n        this.removeTwoChecks(row1, card1, row2, card2);\r\n\r\n        // Checks if the given cards are exposed.\r\n        if (this.isCovered(row1, card1) || this.isCovered(row2, card2)) {\r\n            throw new Error(\"The card at the given index is covered and therefore \"\r\n                + \"cannot be removed.\");\r\n        }\r\n        // Replaces the given cards with null\r\n        this.pyramid[row1][card1] = null;\r\n        this.pyramid[row2][card2] = null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute a single-card move on the pyramid, using the specified card position.\r\n     *\r\n     * @param row  row of the desired card position, numbered from 0 from the top of the pyramid\r\n     * @param card card of the desired card position, numbered from 0 from left\r\n     * @throws Error if the move is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    remove(row: number, card: number): void {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given row is in bounds from this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is in bounds from this game's pyramid.\r\n        if (!this.isCardInBounds(row, card)) {\r\n            throw new Error(\r\n                \"The given card index is out of bounds for the given row.\");\r\n        }\r\n        // Checks if the given card is null.\r\n        if (this.getCardAt(row, card) == null) {\r\n            throw new Error(\"No card at the given index. \");\r\n        }\r\n        // Checks if the given card has a value of the removal value.\r\n        if (this.getCardAt(row, card).getValue() != this.removalValue) {\r\n            throw new Error(\"The given card does not have a value of 13, \"\r\n                + \"and therefore cannot be removed.\");\r\n        }\r\n        // Checks if the given card is covered.\r\n        if (this.isCovered(row, card)) {\r\n            throw new Error(\"The card at the given index is covered and therefore \"\r\n                + \"cannot be removed.\");\r\n        }\r\n\r\n        // Sets the card at the given index to null.\r\n        this.pyramid[row][card] = null;\r\n    }\r\n\r\n    /**\r\n     * Execute a two-card move, using the specified card from the draw pile and the specified card\r\n     * from the pyramid.\r\n     *\r\n     * @param row  row of the desired card position, numbered from 0 from the top of the pyramid\r\n     * @param card card of the desired card position, numbered from 0 from left\r\n     * @throws Error if the move is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    removeUsingDraw(drawIndex: number, row: number, card: number): void {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given row is in bounds for this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is in bounds for this game's pyramid.\r\n        if (!this.isCardInBounds(row, card)) {\r\n            throw new Error(\r\n                \"The given card index is out of bounds for the given row.\");\r\n        }\r\n        // Checks if the given draw index is in bounds for the number of draw cards.\r\n        if (drawIndex >= this.draws.length || drawIndex < 0) {\r\n            throw new Error(\"The given draw index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is null.\r\n        if (this.getCardAt(row, card) == null) {\r\n            throw new Error(\"No card at the given index: \"+ row+ \", \" + card+\".\");\r\n        }\r\n        if (this.draws[drawIndex] == null) {\r\n            throw new Error(\"No card at the given index: \"+ drawIndex +\".\");\r\n        }\r\n        // Checks if the given draw card and pyramid card add up to the removal value.\r\n        if (this.getCardAt(row, card).getValue() + this.draws[drawIndex].getValue()\r\n            != this.removalValue) {\r\n            throw new Error(\"The given cards do not sum to a value of 13, \"\r\n                + \"and therefore cannot be removed.\");\r\n        }\r\n        // Checks if the given pyramid card is covered.\r\n        if (this.isCovered(row, card)) {\r\n            throw new Error(\"The card at the given index is covered and therefore \"\r\n                + \"cannot be removed.\");\r\n        }\r\n\r\n        // Sets pyramid card to null and discards the given draw card.\r\n        this.pyramid[row][card] = null;\r\n        this.discardDraw(drawIndex);\r\n    }\r\n\r\n    /**\r\n     * Discards an individual card from the draw pile.\r\n     *\r\n     * @param drawIndex the card to be discarded\r\n     * @throws Error if the index is invalid or no card is present there.\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    discardDraw(drawIndex: number): void {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given drawIndex is in bounds for the length of draws.\r\n        if (drawIndex < 0 || drawIndex >= this.draws.length) {\r\n            throw new Error(\"Index does not exist in the draw pile.\");\r\n        }\r\n        // Checks if there is a card at the given index.\r\n        if (this.draws[drawIndex] == null) { //should deal with 0 index 0 length\r\n            throw new Error(\"There is no card at this index.\");\r\n        }\r\n        // removes the given card\r\n        //delete this.draws[drawIndex];\r\n        // replaces the card absent in draws if there is one available\r\n        if (this.stock.length > 0) {\r\n            this.draws[drawIndex] = (this.stock[0])\r\n            this.stock.shift();\r\n        } else {\r\n            this.draws[drawIndex] = null;\r\n              //  this.draws.push(null);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns the number of rows originally in the pyramid, or -1 if the game hasn't been started.\r\n     *\r\n     * @return the height of the pyramid, or -1\r\n     */\r\n    getNumRows(): number {\r\n        // Checks if this game has started.\r\n        if (this.gamestate == GameState.NOT_STARTED) {\r\n            return -1;\r\n        }\r\n        // returns the height of this game's pyramid\r\n        return this.pyramid.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum number of visible cards in the draw pile, or -1 if the game hasn't been\r\n     * started.\r\n     *\r\n     * @return the number of visible cards in the draw pile, or -1\r\n     */\r\n    getNumDraw(): number {\r\n        // Checks if this game has started.\r\n        if (this.gamestate == GameState.NOT_STARTED) {\r\n            return -1;\r\n        }\r\n        // returns the length of this game's draws list\r\n        return this.draws.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the requested row, measured from the leftmost card to the rightmost card\r\n     * (inclusive) as the game is initially dealt.\r\n     *\r\n     * @param row the desired row (0-indexed)\r\n     * @return the number of spaces needed to deal out that row\r\n     * @throws Error if the row is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    getRowWidth(row: number): number {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the row is in bounds for this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row is out of bounds.\");\r\n        }\r\n        // returns the length of the given row\r\n        return this.pyramid[row].length;\r\n    }\r\n\r\n    /**\r\n     * Signal if the game is over or not.\r\n     *\r\n     * @return true if game is over, false otherwise\r\n     * @throws IllegalStateException if the game hasn't been started yet\r\n     */\r\n    isGameOver(): boolean {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the game has been won.\r\n        if (this.isGameWon()) {\r\n            return true;\r\n        }\r\n\r\n        // checks if draws is empty\r\n        this.draws.forEach(function (value) {\r\n            if (value != null) {\r\n                return false;\r\n            }\r\n        });\r\n\r\n        let uncovered: Array<Card> = this.getUncovered();\r\n\r\n        // iterates over all the uncovered cards and checks\r\n        // if any of them evaluate to the removal value.\r\n        if (this.canBeRemoved(uncovered)) {\r\n            return false;\r\n        }\r\n\r\n        // iterates over all the uncovered cards and checks if any pair may add up to the removal value.\r\n        if (this.canAddToRemovalValue(uncovered)) {\r\n            return false;\r\n        }\r\n\r\n        //checks if there are cards in stock, and if we have draw space to access them.\r\n        return !(this.getNumDraw() > 0 && this.stock.length > 0);\r\n    }\r\n\r\n    /**\r\n     * Return the current score, which is the sum of the values of the cards remaining in the\r\n     * pyramid.\r\n     *\r\n     * @return the score\r\n     * @throws IllegalStateException if the game hasn't been started yet\r\n     */\r\n    getScore(): number {\r\n        // Checks if this game has started.\r\n        this.checkStarted();\r\n\r\n        if (this.isGameWon()) {\r\n            return 0;\r\n        }\r\n\r\n        // iterates through the results and adds up the values\r\n        let result: number = 0;\r\n        for (let row = 0 ; row < this.pyramid.length ; row++) {\r\n            for (let col = 0 ; col < this.pyramid[row].length; col++) {\r\n                if(this.pyramid[row][col] != null) {\r\n                    result = result + this.pyramid[row][col].getValue();\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the card at the specified coordinates.\r\n     *\r\n     * @param row  row of the desired card (0-indexed from the top)\r\n     * @param card column of the desired card (0-indexed from the left)\r\n     * @return the card at the given position, or <code>null</code> if no card is there\r\n     * @throws Error if the coordinates are invalid\r\n     * @throws Error if the game hasn't been started yet\r\n     */\r\n    getCardAt(row: number, card: number): Card {\r\n        // Checks if this game has started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given row is in bounds for this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is in bounds for this game's pyramid.\r\n        if (!this.isCardInBounds(row, card)) {\r\n            throw new Error(\"The given card index is out of bounds.\");\r\n        }\r\n\r\n        // returns the card at the given index\r\n        return this.pyramid[row][card];\r\n    }\r\n\r\n    /**\r\n     * Returns the currently available draw cards. There should be at most {@link\r\n        * PyramidSolitaireModel#getNumDraw} cards (the number specified when the game started) -- there\r\n     * may be fewer, if cards have been removed.\r\n     *\r\n     * @return the ordered list of available draw cards\r\n     * @throws Error if the game hasn't been started yet\r\n     */\r\n    getDrawCards(): Array<Card> {\r\n        // Checks if the game has started.\r\n        this.checkStarted();\r\n\r\n        // Makes a copy of the draw cards list and returns it\r\n        let drawsCopy: Array<Card> = new Array<Card>();\r\n        this.draws.forEach(function(card){\r\n            drawsCopy.push(card);\r\n        });\r\n        return drawsCopy;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the card at the given row and card index is covered, meaning that it has\r\n     * non-null card values in the two spaces directly below the card itself.\r\n     *\r\n     * @param row  the row index of the card we are checking\r\n     * @param card the card index of the card we are checking\r\n     * @return whether the card at the given index is covered\r\n     */\r\n    protected isCovered(row: number, card: number): boolean {\r\n        // Checks if the given row index is in bounds for this game's pyramid.\r\n        if (row >= this.pyramid.length || row < 0) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card index is in bounds for this game's pyramid.\r\n        if (card >= this.pyramid[row].length || card < 0) {\r\n            throw new Error(\"The given card index is out of bounds\"\r\n                + \" for the given row.\");\r\n        }\r\n        // Checks if the card at the given index is in the bottom row.\r\n        if (row == this.pyramid.length - 1) {\r\n            return false;\r\n        } else {\r\n            // Checks if the cards directly below the card at the given index are null.\r\n            return this.getCardAt(row + 1, card) != null ||\r\n                this.getCardAt(row + 1, card + 1) != null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given deck is valid for this game of pyramid solitaire. Meaning that the\r\n     * given deck has no repeated cards, has no null cards, and is the same size as the valid deck\r\n     * produced by this class.\r\n     *\r\n     * @param deck the List of cards that we are checking for validity\r\n     * @return whether the given list is a valid deck for this game\r\n     */\r\n    protected abstract isValidDeck(deck: Array<Card>): boolean;\r\n\r\n    /**\r\n     * Returns whether this game is won, meaning there are no cards left in the pyramid, or rather\r\n     * that all cards in the pyramid are null.\r\n     *\r\n     * @return whether all of the cards in this game's pyramid are null.\r\n     */\r\n    protected isGameWon(): boolean {\r\n        // iterates over the cards in this game's pyramid and checks if any are not null\r\n\r\n        for (let row = 0 ; row < this.pyramid.length ; row++) {\r\n            for (let col = 0 ; col < this.pyramid[row].length; col++) {\r\n                if (this.pyramid[row][col] != null) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a deck of the given size could be used to deal a pyramid of the given number of\r\n     * rows, with the given number of draws.\r\n     *\r\n     * @param deckSize the size of the deck in question\r\n     * @param numRows  the number of rows in the pyramid in question\r\n     * @param numDraws the number of draws in the game in question\r\n     * @return if a deck of the given size has enough cards to deal\r\n     */\r\n    protected abstract isEnoughCards(deckSize: number, numRows: number, numDraws: number): boolean;\r\n\r\n    /**\r\n     * Returns whether the given row index is in bounds for this game's pyramid. Meaning, a row of the\r\n     * given index exists in the pyramid.\r\n     *\r\n     * @param row the row index\r\n     * @return whether the row is in bounds for this game's pyramid\r\n     */\r\n    protected isRowInBounds(row: number): boolean {\r\n        return row < this.pyramid.length && row >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the given card index is in bounds for the given row for this game's pyramid.\r\n     * Meaning, a row of the given index exists, and a card of the given index in the given row\r\n     * exists.\r\n     *\r\n     * @param row  the row index\r\n     * @param card the card index\r\n     * @return whether the card is within the bounds of this game's pyramid\r\n     */\r\n    protected isCardInBounds(row: number, card: number): boolean {\r\n        return this.isRowInBounds(row) && card < this.pyramid[row].length && card >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns whether any of the cards in the given list can be removed by themselves, assuming all\r\n     * the given cards are uncovered (can be removed) and that in order to be removed the card value\r\n     * must match the removal value.\r\n     *\r\n     * @param cards the list of cards being checked\r\n     * @return whether the given list of cards contains cards which can be removed\r\n     */\r\n    private canBeRemoved(cards: Array<Card>): boolean {\r\n        // iterates over all of the cards in the given list and\r\n        // checks if they have a value equal to the removal value\r\n\r\n        for (let index = 0; index < cards.length ; index++) {\r\n            if (cards[index].getValue() == this.removalValue) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether any two cards in the given list of cards can sum to the removal value of this\r\n     * game.\r\n     *\r\n     * @param cards list of cards to be checked\r\n     * @return whether there exists in the list a pair of cars that sum to the removal value\r\n     */\r\n    private canAddToRemovalValue(cards: Array<Card>): boolean {\r\n        // iterates over every possible pairing of cards in the given list of cards\r\n        for (let card1 = 0; card1 < cards.length; card1 += 1) {\r\n            for (let card2 = 0; card2 < cards.length; card2 += 1) {\r\n                if (card1 != card2 &&\r\n                    cards[card1].getValue() + cards[card2].getValue() == this.removalValue) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the uncovered cards in this game's pyramid, meaning all of the cards that do\r\n     * not have two cards directly below them in the pyramid.\r\n     *\r\n     * @return list of all uncovered cards in this game's pyramid\r\n     */\r\n    private getUncovered(): Array<Card> {\r\n        let uncovered: Array<Card> = new Array<Card>();\r\n        // iterates over all of the cards in the pyramid and adds the uncovered ones\r\n        for (let row = 0; row < this.pyramid.length; row += 1) {\r\n            for (let card = 0; card < this.pyramid[row].length; card += 1) {\r\n                if (this.getCardAt(row, card) != null && !this.isCovered(row, card)) {\r\n                    uncovered.push(this.getCardAt(row, card));\r\n                }\r\n            }\r\n        }\r\n        return uncovered;\r\n    }\r\n\r\n    /**\r\n     * Checks if this game has been started, if not, throws an IllegalStateException.\r\n     *\r\n     * @throws IllegalStateException when game has not been started\r\n     */\r\n    protected checkStarted(): void {\r\n        if (this.gamestate == GameState.NOT_STARTED) {\r\n            throw new Error(\"The game has not yet started.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the draw pile of this game has only null cards, meaning all draw cards have been\r\n     * discarded.\r\n     *\r\n     * @return whether all cards in this game's draws are discarded (null)\r\n     */\r\n    protected allDiscarded(): boolean {\r\n        this.draws.forEach(function (card) {\r\n            if (card != null) {\r\n                return false;\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the removal of the cards with the given indexes is possible, errors if not.\r\n     */\r\n    protected removeTwoChecks(row1: number, card1: number, row2: number, card2: number): void{\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n        // Checks if the given rows are within the bounds of this game's pyramid.\r\n        if (!this.isRowInBounds(row1) || !this.isRowInBounds(row2)) {\r\n            throw new Error(\"The given row is out of bounds.\");\r\n        }\r\n        // Checks if the given cards are within the bounds of the game's pyramid.\r\n        if (!this.isCardInBounds(row1, card1) || !this.isCardInBounds(row2, card2)) {\r\n            throw new Error(\"The given card is out of bounds for the given row.\");\r\n        }\r\n        // Checks if either of the given cards is null.\r\n        if (this.getCardAt(row1, card1) == null) {\r\n            throw new Error(\"No card at the given index, \" + row1 + \", \" + card1 + \".\");\r\n        }\r\n\r\n        if (this.getCardAt(row2, card2) == null) {\r\n            throw new Error(\"No card at the given index, \" + row2 + \", \" + card2 + \".\");\r\n        }\r\n\r\n\r\n        // Checks if the cards at the given indexes add up to the removal value.\r\n        if (this.getCardAt(row1, card1).getValue() + this.getCardAt(row2, card2).getValue()\r\n            != this.removalValue) {\r\n            throw new Error(\"The given cards do not add up to 13, and \"\r\n                + \"therefore cannot be removed.\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","/**\r\n * Represents the possible suits of the cards in a standard 52 card deck. Represented as one of:\r\n * <ul>\r\n *   <li>HEART</li>\r\n *   <li>SPADE</li>\r\n *   <li>CLUB</li>\r\n *   <li>DIAMOND</li>\r\n * </ul>\r\n */\r\nexport enum Suit {\r\n    HEART = \"♥\",\r\n    SPADE = \"♠\",\r\n    CLUB = \"♣\",\r\n    DIAMOND = \"♦\"\r\n}","import {Suit} from \"./Suit\";\r\n\r\n/**\r\n * Represents a card in a standard deck of 52 with a suit and a value.\r\n */\r\nexport class Card {\r\n    private suit : Suit;\r\n    value : number;\r\n\r\n    /**\r\n     * Constructs a {@code Card} object.\r\n     *\r\n     * @param suit  the suit of the card\r\n     * @param value the numerical value of the card\r\n     */\r\n    constructor(suit:Suit, value:number) {\r\n        this.suit = suit;\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this card.\r\n     *\r\n     * @return the value field of this card\r\n     */\r\n    getValue(): number {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Equality check for a given object and this Card, returns true if the given object is a Card,\r\n     * and all the attributes of the given Card are the same as this card.\r\n     * @param obj the object to be checked for equality with this one\r\n     */\r\n    equals(obj: any): boolean {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Card)) {\r\n            return false;\r\n        }\r\n        let that : Card = <Card> obj;\r\n        return this.value == that.value &&\r\n            this.suit == that.suit;\r\n    }\r\n\r\n     toString(): string {\r\n        if (this.value == 1) {\r\n            return \"A\" + this.suit.toString();\r\n        } else if (this.value == 11) {\r\n            return \"J\" + this.suit.toString();\r\n        } else if (this.value == 12) {\r\n            return \"Q\" + this.suit.toString();\r\n        } else if (this.value == 13) {\r\n            return \"K\" + this.suit.toString();\r\n        } else {\r\n            return \"\" + this.value + this.suit.toString();\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","import {AbstractPyramidSolitaire} from \"./AbstractPyramidSolitaire\";\r\nimport {Card} from \"./Card\";\r\nimport {Suit} from \"./Suit\";\r\n\r\n/**\r\n * Represents the abstract functionality for a game of PyramidSolitaire, specifically the\r\n * functionality for games with boards in the shape of a single pyramid.\r\n */\r\nexport abstract class AbstractSinglePyramidSolitaireModel extends AbstractPyramidSolitaire {\r\n\r\n    /**\r\n     * Return a valid and complete deck of cards for a game of Pyramid Solitaire. There is no\r\n     * restriction imposed on the ordering of these cards in the deck. The validity of the deck is\r\n     * determined by the rules of the specific game in the classes implementing this interface.\r\n     *\r\n     * @return the deck of cards as a list\r\n     */\r\n    getDeck(): Array<Card> {\r\n        let deck: Array<Card> = new Array<Card>();\r\n        // creates an array containing all of the suits\r\n        let suits: Array<Suit> = new Array<Suit>();\r\n        suits.push(Suit.HEART);\r\n        suits.push(Suit.SPADE);\r\n        suits.push(Suit.CLUB);\r\n        suits.push(Suit.DIAMOND);\r\n        // Creates cards with every value and suit\r\n        suits.forEach(function(suit){\r\n            for (let x = 1; x < 14; x++) {\r\n                deck.push(new Card(suit, x));\r\n            }\r\n        });\r\n        return deck;\r\n    }\r\n\r\n    protected dealCards(numRows: number, deck: Array<Card>, shuffle:boolean) {\r\n        let result: Array<Array<Card>> = new Array<Array<Card>>();\r\n\r\n        // iterates over all the row indexes and creates rows for them\r\n        for (let rowIndex = 0; rowIndex < numRows; rowIndex += 1) {\r\n            let row: Array<Card> = new Array<Card>();\r\n            result.push(row);\r\n        }\r\n\r\n        // shuffles the deck if indicated\r\n        if (shuffle) {\r\n            this.shuffle(deck);\r\n        }\r\n\r\n        // adds all the cards necessary for a pyramid of the given size to the result from the deck\r\n        for (let row = 0; row < numRows; row += 1) {\r\n            for (let card = 0; card <= row; card += 1) {\r\n                result[row].push(deck[0]);\r\n                deck.shift();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    protected isValidDeck(deck: Array<Card>): boolean {\r\n        // iterates over every possible pairing of the cards in the given deck to check for\r\n        // duplicates.\r\n        for (let index = 0; index < deck.length; index += 1) {\r\n            for (let jindex = 0; jindex < deck.length; jindex += 1) {\r\n                if (index != jindex && deck[index].equals(deck[jindex])) {\r\n                    return false;\r\n                }\r\n\r\n            }\r\n            // checks if any card in the given deck is null\r\n            if (deck[index] == null) {\r\n                return false;\r\n            }\r\n        }\r\n        // checks that the given deck is of the same size as a valid deck for this game\r\n        return deck.length == this.getDeck().length;\r\n    }\r\n\r\n    protected isEnoughCards(deckSize: number, numRows: number, numDraws: number): boolean {\r\n        let pyramidSize: number = (numRows * (numRows + 1)) / 2;\r\n        return pyramidSize + numDraws <= deckSize;\r\n    }\r\n\r\n    shuffle(array: Array<any>): Array<any> {\r\n        var currentIndex = array.length, temporaryValue, randomIndex;\r\n\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n\r\n}","import {Card} from \"./Card\";\r\nimport {AbstractSinglePyramidSolitaireModel} from \"./AbstractSinglePyramidSolitaireModel\";\r\n\r\n/**\r\n * Represents the model of a game of pyramid solitaire, which is a game of solitaire in which the\r\n * cards are dealt into a pyramid shaped arrangement before playing. Holds all of the functionality\r\n * for the game including the dealing of cards, removal of cards, and the discarding of cards based\r\n * on the rules of this game.\r\n * <p> Cards may be removed in singles or as pairs with one card being from the pyramid of\r\n * cards and one being from the draw cards, or both cards being from the pyramid. The goal of the\r\n * game is to remove as many cards as possible, because to win the game all cards must be removed.\r\n * The game ends when there are no more possible removals, no more draws which can be discarded, or\r\n * the game has been won. </p>\r\n */\r\nexport class BasicPyramidSolitaire extends AbstractSinglePyramidSolitaireModel {\r\n\r\n    /**\r\n     * Constructs a {@code BasicPyramidSolitaire} object.\r\n     */\r\n    constructor() {\r\n        // instantiates GameStart to be not yet started.\r\n        super();\r\n    }\r\n\r\n    getPyramid(): Array<Array<Card>> {\r\n        let result: Array<Array<Card>> = new Array<Array<Card>>();\r\n        this.pyramid.forEach(function (row) {\r\n            let rowCopy: Array<Card> = new Array<Card>();\r\n            row.forEach(function (card) {\r\n                rowCopy.push(card);\r\n            })\r\n            result.push(rowCopy);\r\n        })\r\n        return result;\r\n    }\r\n}","/**\r\n * Represents an (x, y) position on the cartesian plane.\r\n */\r\nexport class Pos2D {\r\n    private readonly x: number;\r\n    private readonly y: number;\r\n\r\n    /**\r\n     * Creates a Pos2D object.\r\n     *\r\n     * @param x the x coordinate\r\n     * @param y the y coordinate\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Returns the x plane value of this position.\r\n     *\r\n     * @return the x plane coordinate of this position\r\n     */\r\n    getX(): number {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Returns the y plane value of this position.\r\n     *\r\n     * @return the y plan coordinate of this position\r\n     */\r\n    getY(): number {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Equality check for a given object and this Pos2D, returns true if the given object is a Pos2D,\r\n     * and all the attributes of the given Pos2D are the same as this pos.\r\n     * @param obj the object to be checked for equality with this one\r\n     */\r\n    equals(obj: any): boolean {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Pos2D)) {\r\n            return false;\r\n        }\r\n        let that: Pos2D = <Pos2D> obj;\r\n        return this.x == that.x\r\n            && this.y == that.y;\r\n    }\r\n\r\n\r\n}","import {Pos2D} from \"./Pos2D\";\r\n\r\n/**\r\n * Represents a drawable card for a visual view of a game of solitaire.\r\n */\r\nexport class ViewCard {\r\n    private selected: boolean;\r\n    private visible: boolean;\r\n    private screenPos: Pos2D;\r\n    private pyramidPos: Pos2D;\r\n    private label: String;\r\n    private readonly isDrawCard: boolean;\r\n    readonly CARD_WIDTH = 60;\r\n    readonly CARD_HEIGHT = 70;\r\n\r\n    /**\r\n     * Creates a viewCard object with the given attributes.\r\n     * @param screenPos the position of the card on the screen.\r\n     * @param pyramidPos the position of the card in the pyramid.\r\n     * @param label the label of the card.\r\n     * @param isDrawCard whether the card to be created is a drawCard.\r\n     */\r\n    constructor(screenPos: Pos2D, pyramidPos: Pos2D, label: string, isDrawCard: boolean) {\r\n        this.selected = false;\r\n        this.visible = true;\r\n        this.screenPos = screenPos;\r\n        this.pyramidPos = pyramidPos;\r\n        this.label = label;\r\n        this.isDrawCard = isDrawCard;\r\n    }\r\n\r\n\r\n    /**\r\n     * Renders this viewCard with the given graphics.\r\n     *\r\n     * @param context the graphics to be rendered with.\r\n     */\r\n    render(context: CanvasRenderingContext2D): void {\r\n        context.font = \"25px Veranda\"\r\n        if (this.visible) { // if the card is visible\r\n            if (this.selected) { // if the card is selected\r\n                // renders the card\r\n                context.fillStyle = \"#65b577\";\r\n                context.fillRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // renders the accents and label\r\n                context.fillStyle = \"#064112\";\r\n                context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // might need to add font styling here\r\n\r\n                context.fillText(<string>this.label, this.screenPos.getX() + this.CARD_WIDTH / 4,\r\n                    this.screenPos.getY() + this.CARD_HEIGHT / 2);\r\n\r\n            } else { // if the card is not selected\r\n                // renders the card\r\n                context.fillStyle = \"#ffffff\";\r\n                context.fillRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // renders the accents and label\r\n                if (this.redSuit(this.label)) {\r\n                    context.fillStyle = \"#ef0707\";\r\n                } else {\r\n                    context.fillStyle = \"#000000\";\r\n                }\r\n                context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // might need to add font styling here\r\n                context.fillText(<string>this.label, this.screenPos.getX() + this.CARD_WIDTH / 4,\r\n                    this.screenPos.getY() + this.CARD_HEIGHT / 2);\r\n            }\r\n        } else { // if the card is not visible\r\n            if (this.redSuit(this.label)) {\r\n                context.fillStyle = \"#ef0707\";\r\n            } else {\r\n                context.fillStyle = \"#000000\";\r\n            }\r\n            context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                this.CARD_WIDTH, this.CARD_HEIGHT);\r\n\r\n        }\r\n    }\r\n\r\n    setSelected(selected: boolean): void {\r\n        this.selected = selected;\r\n    }\r\n\r\n    setVisible(visible: boolean): void {\r\n        this.visible = visible;\r\n    }\r\n\r\n    setPyramidPosition(pyramidPosition: Pos2D): void {\r\n        this.pyramidPos = pyramidPosition;\r\n    }\r\n\r\n    setLabel(label: string): void {\r\n        // checks if the given label is null\r\n        if (label == null) {\r\n            throw new Error(\"The given label cannot be null.\");\r\n        }\r\n        this.label = label;\r\n    }\r\n\r\n    getScreenPosition(): Pos2D {\r\n        // returns copy to disallow mutation\r\n        return new Pos2D(this.screenPos.getX(), this.screenPos.getY());\r\n    }\r\n\r\n    getPyramidPosition(): Pos2D {\r\n        // returns copy to disallow mutation\r\n        return new Pos2D(this.pyramidPos.getX(), this.pyramidPos.getY());\r\n    }\r\n\r\n    getSelected(): boolean {\r\n        return this.selected;\r\n    }\r\n\r\n    getVisible(): boolean {\r\n        return this.visible;\r\n    }\r\n\r\n    getLabel(): String {\r\n        return this.label;\r\n    }\r\n\r\n    isDrawCardCheck(): boolean {\r\n        return this.isDrawCard;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the card in the form of a string, one of: \"♥\", \"♠\", \"♣\", \"♦\".\r\n     * @param card the card whose type will be returned.\r\n     * @return the type of the card in the form of a string.\r\n     */\r\n    private suitType(card: ViewCard): string {\r\n        return card.getLabel().substring(card.getLabel().length-1);\r\n    }\r\n\r\n    private redSuit(type: String): boolean {\r\n        return (type.substring(type.length-1).localeCompare(\"♥\") == 0 ||\r\n            type.substring(type.length-1).localeCompare(\"♦\") == 0);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import {ViewCard} from \"./ViewCard\";\r\nimport {PyramidSolitaireVisualController} from \"./PyramidSolitaireVisualController\";\r\nimport {Card} from \"./Card\";\r\nimport {Pos2D} from \"./Pos2D\";\r\n\r\n\r\n\r\n/**\r\n * Represents the visual view for a game of Pyramid Solitaire\r\n */\r\nexport class PyramidSolitaireVisualView {\r\n    private controller: PyramidSolitaireVisualController;\r\n    private canvas: HTMLCanvasElement;\r\n    private readonly context: CanvasRenderingContext2D;\r\n    selected: number;\r\n    drawsSelected: number;\r\n    private score: number;\r\n    private readonly cards: Array<ViewCard>;\r\n     manager = this;\r\n\r\n    /**\r\n     * Creates a PyramidSolitaireVisualView object with the given canvasRenderingContext for rendering.\r\n     */\r\n    constructor(canvas: HTMLElement, removeButton: HTMLElement, rulesButton: HTMLElement) {\r\n        this.selected = 0;\r\n        this.drawsSelected = 0;\r\n        this.score = 0;\r\n        this.canvas = <HTMLCanvasElement> canvas;\r\n        this.cards = new Array<ViewCard>();\r\n        const canvas2: HTMLCanvasElement = <HTMLCanvasElement> canvas;\r\n        const ctx = canvas2.getContext(\"2d\");\r\n        this.context = ctx;\r\n        // adding click action listener\r\n        canvas.addEventListener('click', this.mouseListener.bind(this), false);\r\n        // adds button action listeners\r\n        removeButton.addEventListener('click', this.removeButtonActionListener.bind(this), false);\r\n        rulesButton.addEventListener('click', this.rulesButtonActionListener, false);\r\n\r\n    }\r\n\r\n    /**\r\n     * Starts the ability of the view and the controller to communicate allowing the interactive\r\n     * features of the game of pyramid solitaire.\r\n     * @param controller the controller this view will interact with\r\n     */\r\n    beginInteraction(controller: PyramidSolitaireVisualController): void {\r\n        this.controller = controller;\r\n    }\r\n\r\n    /**\r\n     * Repaints the visual view.\r\n     */\r\n    refresh(): void {\r\n        // sets the background\r\n        this.context.font = \"25px Veranda\"\r\n        this.context.fillStyle = \"#0b8327\";\r\n        this.context.fillRect(0, 0, 700, 800); // make the width and height constants\r\n\r\n        // draws the score and draws labels and suit value labels\r\n        this.context.fillStyle = \"#ffffff\";\r\n        this.context.fillText(\"Draws:\", 25, 500);\r\n        this.context.fillText(\"Suit Values:\", 25, 175);\r\n        this.context.fillText(\" K - 13\", 25, 200);\r\n        this.context.fillText(\" Q - 12\", 25, 225);\r\n        this.context.fillText(\"  J - 11\", 25, 250);\r\n\r\n\r\n        // win screen if the score of 0 is met\r\n        if (this.score == 0) {\r\n            this.context.font = \"35px Veranda\"\r\n            this.context.fillText(\"You Won! \", 500, 175);\r\n        } else { // if the game is not won\r\n            this.context.font = \"25px Veranda\"\r\n            this.context.fillText(\"Score: \" + this.score, 500, 175);\r\n        }\r\n        // renders each of the viewCards\r\n        for (let index = 0 ; index < this.cards.length; index++) {\r\n            this.cards[index].render(this.context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the given viewShape in the visual view.\r\n     *\r\n     * @param viewCard the viewShape to be drawn.\r\n     */\r\n    drawCard(card: ViewCard): void {\r\n        this.cards.push(card);\r\n    }\r\n\r\n    /**\r\n     * Makes the card with the given position in the pyramid invisible, if possible.\r\n     * @param pyramidPos the position of the card to be made invisible\r\n     */\r\n    makeInvisible(pyramidPos: Pos2D): void {\r\n        // iterates over all the viewCards and makes the cards with the given pyramid positions invisible\r\n        for (let index = 0 ; index < this.cards.length ; index ++) {\r\n            if (this.cards[index].getPyramidPosition().equals(pyramidPos)\r\n                && !this.cards[index].isDrawCardCheck()) {\r\n                this.cards[index].setVisible(false);\r\n                this.cards[index].setSelected(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual representation of the draw cards taking into consideration the card which\r\n     * has just been removed.\r\n     * @param removedDraw the position of the removed draw card.\r\n     * @param newDrawCards a list of the new draw cards.\r\n     */\r\n    updateDraws(removedDraw: Pos2D, newDrawCards: Array<Card>) {\r\n        let drawCards: Array<ViewCard> = this.getDrawCards();\r\n        // updates the card which has been removed\r\n        let removedCard:ViewCard = null;\r\n        // iterates over all the draw cards to find the one which has been removed\r\n        for (let index = 0 ; index < drawCards.length; index++) {\r\n            if (drawCards[index].getPyramidPosition().equals(removedDraw)) {\r\n                removedCard = drawCards[index];\r\n            }\r\n        }\r\n\r\n        let replacementCard: Card = newDrawCards[removedCard.getPyramidPosition().getX()];\r\n        removedCard.setLabel(replacementCard.toString());\r\n        removedCard.setSelected(false);\r\n\r\n        // resets the indexes to match the given draw card list\r\n        for (let index = 0; index < drawCards.length; index++) {\r\n            drawCards[index].setPyramidPosition(new Pos2D(\r\n                newDrawCards.indexOf(this.getMatchingCard(\r\n                    drawCards[index].getLabel(), newDrawCards)), -1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets all of the viewCards with the given positions to be deselected.\r\n     * @param cardPositions the positions to deselect\r\n     */\r\n    deselect(cardPositions: Array<Pos2D>): void {\r\n        // iterates over the viewCards and deselects the ones with the given positions\r\n        for (let index = 0; index < this.cards.length; index++) {\r\n            for (let posIndex = 0 ; posIndex < cardPositions.length; posIndex++) {\r\n                if (cardPositions[posIndex].equals(this.cards[index].getPyramidPosition())) {\r\n                    this.cards[index].setSelected(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    printMessage(message: String): void {\r\n        this.context.fillStyle = \"#020101\";\r\n        this.context.fillText(<string>message, 30, 550);\r\n    }\r\n\r\n    /**\r\n     * Updates the score of the game to be rendered by the view for the user to see.\r\n     * @param score the score to be rendered\r\n     */\r\n    updateScore(score: number): void {\r\n        this.score = score;\r\n    }\r\n\r\n    /**\r\n     * Handles mouseEvents for the visual view of the game of solitaire.\r\n     * @param e the mouseEvent\r\n     */\r\n    mouseListener(e: MouseEvent): void { // may need to use an altered position\r\n        let pageOffset: number = 32;\r\n            this.selectCard(e.pageX, e.pageY-pageOffset);\r\n            this.refresh();\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Handles action events for the remove selected button of this view.\r\n     * @param e the action event.\r\n     */\r\n    private removeButtonActionListener(e: Event): void {\r\n        this.controller.removeSelected(this.getSelectedCards());\r\n        this.resetSelected();\r\n    }\r\n\r\n    /**\r\n     * Handles action events for the rules button of this view.\r\n     * @param e the action event.\r\n     */\r\n    private rulesButtonActionListener(e: Event): void {\r\n        alert(\"The goal of a game of pyramid solitaire is to clear \" +\r\n            \"the pyramid by removing the cards one or two at a time.\\n To remove a card or pair of \" +\r\n            \"cards the value(s) of the card(s) must sum to 13. \" +\r\n            \"\\n You may only remove cards that are not covered, meaning the two spots below the card are\" +\r\n            \" empty. \\n You may use draw cards paired with \" +\r\n            \"pyramid cards, or discard any draw card and it will be replaced by the next in the deck.  \\n\" +\r\n            \" The score represents the sum of the \" +\r\n            \"values of the cards in the pyramid, so the goal, like in golf, \" +\r\n            \"is to get the lowest score possible.\\n A score of zero wins the game.\");\r\n    }\r\n\r\n    /**\r\n     * Returns the positions of the cards in this panel that have been selected by the user.\r\n     * @return an array of the positions of the selected cards in this panel.\r\n     */\r\n    private getSelectedCards(): Array<Pos2D> {\r\n        let pyramidPositions: Array<Pos2D> = new Array<Pos2D>();\r\n        // iterates over all the viewCards and adds the selected ones to the result\r\n        for (let index = 0; index < this.cards.length; index++) {\r\n            if (this.cards[index].getSelected()) {\r\n                pyramidPositions.push(this.cards[index].getPyramidPosition());\r\n            }\r\n        }\r\n        return pyramidPositions;\r\n    }\r\n\r\n    /**\r\n     * Sets this view's selected and drawsSelected field back to zero.\r\n     */\r\n    private resetSelected(): void {\r\n        this.selected = 0;\r\n        this.drawsSelected = 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Selects the card containing the given x and y positions on the screen, if there is no card with the given\r\n     * position, does nothing.\r\n     * @param screenX the x position on the screen of the card we are selecting\r\n     * @param screenY the y position on the screen of the card we are selecting\r\n     */\r\n    selectCard(x: number, y: number): void {\r\n        for (let index = 0 ; index < this.cards.length ; index ++) {\r\n            let card: ViewCard = this.cards[index];\r\n            // checks if if the card clicked is card, and if that card is uncovered\r\n            if (x > card.getScreenPosition().getX() && x < card.getScreenPosition().getX() + 60 &&\r\n                y > card.getScreenPosition().getY() && y < card.getScreenPosition().getY() + 70 - 10\r\n               && this.notCovered(card.getPyramidPosition(), card.isDrawCardCheck())) {\r\n                // toggles the card selected status\r\n                if (card.getSelected()) { // if the card is already selected\r\n                    this.selected--;\r\n                    if (card.isDrawCardCheck()) {\r\n                        this.drawsSelected--;\r\n                    }\r\n                    card.setSelected(!card.getSelected());\r\n                } else if ( // if the card is not selected\r\n                    (this.selected < 2  && card.getVisible()) && //the card is valid and less than 2 cards are selected\r\n                    ((!card.isDrawCardCheck()) || // the card is not a draw\r\n                    (card.isDrawCardCheck() && this.drawsSelected < 1 ))) { // the card is a draw and can be selected\r\n                    this.selected++;\r\n                    if (card.isDrawCardCheck()) {\r\n                        this.drawsSelected++;\r\n                    }\r\n                    card.setSelected(!card.getSelected());\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the card containing the given x and y positions on the screen, returns null if there is none.\r\n     * @param screenX the x position on the screen of the card we are getting\r\n     * @param screenY the y position on the screen of the card we are getting\r\n     * @return the card in this panel containing given position on the screen\r\n     */\r\n    getCard(x: number, y: number): ViewCard {\r\n        this.cards.forEach(function (card) {\r\n            // checks if the card contains the given x, y coordinates\r\n            if (x > card.getScreenPosition().getX() && x < card.getScreenPosition().getX() + 60 &&\r\n                y > card.getScreenPosition().getY() && y < card.getScreenPosition().getY() + 70 - 10) {\r\n                // returns a copy of the card if it is the one with the given coordinates\r\n                 let result: ViewCard = new ViewCard(card.getScreenPosition(), card.getPyramidPosition(),\r\n                    <string>card.getLabel(), card.isDrawCardCheck());\r\n                result.setSelected(card.getSelected());\r\n                result.setVisible(card.getVisible());\r\n                return result;\r\n\r\n            }\r\n        });\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of all the cards that are labeled drawCards from this drawingPanel's cards.\r\n     *\r\n     * @return a list of all this panel's drawCards.\r\n     */\r\n    private getDrawCards(): Array<ViewCard> {\r\n        let drawCards: Array<ViewCard> = new Array<ViewCard>();\r\n        // iterates over the viewCards and adds the drawCards to the result\r\n        for (let index = 0; index < this.cards.length; index++) {\r\n            if (this.cards[index].isDrawCardCheck()) {\r\n                drawCards.push(this.cards[index]);\r\n            }\r\n        }\r\n        return drawCards;\r\n    }\r\n\r\n    /**\r\n     * Returns the card from the list of cards with the toString result that matches the given label.\r\n     *\r\n     * @param label the label being searched for\r\n     * @param cards the cards being searched through\r\n     * @return the card with the matching label from the given list\r\n     * @throws IllegalArgumentException if a card with the given label does not exist\r\n     */\r\n    private getMatchingCard(label: String, cards: Array<Card>): Card {\r\n        for (let index = 0; index < cards.length; index++) {\r\n            if (cards[index].toString() == label) {\r\n                return cards[index];\r\n            }\r\n        }\r\n        throw new Error(\"No card with the given label, \" + label);\r\n    }\r\n\r\n    /**\r\n     * Whether the card at the given pyramid position in the pyramid is uncovered, meaning the cards below and to the\r\n     * left and below and to the right of the pyramid position are invisible. If the card is a drawCard it is alwaus\r\n     * uncovered because there are no cards beneath it.\r\n     *\r\n     * @param pyramidPosition the position in question\r\n     * @param isDrawCard      whether the given card is a drawCard\r\n     * @return whether the card with the given attributes is uncovered in the pyramid\r\n     */\r\n    private notCovered(pyramidPosition: Pos2D, isDrawCard: boolean): boolean {\r\n        // if the card is a drawCard return true\r\n        if (isDrawCard) {\r\n            return true;\r\n        }\r\n        // the positions below the given position\r\n        let botLeft: Pos2D = new Pos2D(pyramidPosition.getX() + 1, pyramidPosition.getY());\r\n        let botRight: Pos2D = new Pos2D(pyramidPosition.getX() + 1, pyramidPosition.getY() + 1);\r\n\r\n        // iterates over the viewCards and checks if the ones below the given index are visible\r\n        for (let index=0; index < this.cards.length; index ++) {\r\n            let viewCard = this.cards[index];\r\n            if ((viewCard.getPyramidPosition().equals(botLeft)\r\n                || viewCard.getPyramidPosition().equals(botRight))\r\n                && viewCard.getVisible() && !viewCard.isDrawCardCheck()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    \r\n}","import {Pos2D} from \"./Pos2D\";\r\nimport {ViewCard} from \"./ViewCard\";\r\nimport {Card} from \"./Card\";\r\nimport {BasicPyramidSolitaire} from \"./BasicPyramidSolitaire\";\r\nimport {PyramidSolitaireVisualView} from \"./PyramidSolitaireVisualView\";\r\n\r\n/**\r\n * Represents the controller for the visual version of pyramid solitaire.\r\n * Communicates between the view and the model to allow for the interactive playing of the game.\r\n */\r\nexport class PyramidSolitaireVisualController {\r\n    private view: PyramidSolitaireVisualView;\r\n    private model: BasicPyramidSolitaire;\r\n    readonly CARD_WIDTH = 60;\r\n    readonly CARD_HEIGHT = 70;\r\n\r\n    /**\r\n     * Constructs a PyramidSolitaireVisualController object with the given view and model.\r\n     * @param view the view\r\n     * @param model the model\r\n     */\r\n    constructor(view: PyramidSolitaireVisualView, model: BasicPyramidSolitaire) {\r\n        this.view = view;\r\n        this.model = model;\r\n    }\r\n\r\n    /**\r\n     * Runs a visual game of pyramid solitaire with the given deck and pyramid attributes.\r\n     * @param deck the deck to be used in the game\r\n     * @param shuffle whether or not the deck should be shuffled prior to plau\r\n     * @param numRows the number of rows in the given pyramid\r\n     * @param numDraw the number of draw cards to be used\r\n     */\r\n    playGame(deck: Array<Card>, shuffle: boolean, numRows: number, numDraw: number): void {\r\n        // starts the game in the model and starts the interaction in the view\r\n        this.model.startGame(deck, shuffle, numRows, numDraw);\r\n        console.log(this.model.getPyramid().length);\r\n\r\n        this.view.beginInteraction(this);\r\n\r\n        // creates viewCards for every card in the model\r\n        const pyramid: Array<Array<Card>>  = this.model.getPyramid(); // is const okay\r\n        console.log(pyramid);\r\n        for (let row = 0; row < pyramid.length; row++) {\r\n            for (let col = 0; col < pyramid[row].length; col++) {\r\n               // console.log(row +\" \"+ col);\r\n               this.view.drawCard(\r\n                   this.createPyramidViewCard(pyramid[row][col].toString(), row, col, pyramid.length));\r\n\r\n            }\r\n        }\r\n\r\n        const drawCards: Array<Card> = this.model.getDrawCards();\r\n\r\n        // creates viewCards for every drawCard in the model\r\n        for (let index = 0; index < drawCards.length; index++) {\r\n           this.view.drawCard(this.createDrawViewCard(drawCards[index].toString(), index));\r\n        }\r\n        // updates the score and refreshes the view.\r\n        this.view.updateScore(this.model.getScore());\r\n        this.view.refresh();\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Removes the cards in the pyramid with the given positions if possible.\r\n     * @param cardPositions the positions of the cards being attempted to be removed\r\n     */\r\n    removeSelected(cardPositions: Array<Pos2D>): void {\r\n        if (this.validCards(cardPositions)) {\r\n\r\n            if (cardPositions.length == 1 && this.containsDrawCard(cardPositions)) {\r\n                this.discardDraw(cardPositions);\r\n            } else {\r\n\r\n                try {\r\n                    if (this.containsDrawCard(cardPositions)) {\r\n                        this.removeWithDraw(cardPositions);\r\n                    } else {\r\n                        this.removeWithoutDraw(cardPositions);\r\n                    }\r\n\r\n                    // makes the cards removed from the pyramid invisible\r\n                    for (let index = 0 ; index < cardPositions.length ; index++) {\r\n                        this.view.makeInvisible(cardPositions[index]);\r\n                    }\r\n                } catch (e) {\r\n                    // deselects the cards if they cannot be removed\r\n                    this.view.deselect(cardPositions);\r\n\r\n                }\r\n            }\r\n        } else {\r\n            // deselects the cards if they are an invalid pairing (2 draw cards)\r\n            this.view.deselect(cardPositions);\r\n        }\r\n        // updates the score and refreshes the view\r\n        this.view.updateScore(this.model.getScore());\r\n        this.view.refresh();\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a view card representing a card in the pyramid of the game at the given row\r\n     * col index with the given label within a pyramid of the given height.\r\n     *\r\n     * @param label         the label of the card to be created\r\n     * @param row           the row of the card the returned view card is representing\r\n     * @param col           the column of the card the returned view card is representing\r\n     * @param pyramidHeight the height of the pyramid in which the view card is being created (in rows)\r\n     * @return a view card representing a card with the given attributes within a pyramid of the given height.\r\n     */\r\n    private createPyramidViewCard(label: String, row: number, col: number, pyramidHeight: number): ViewCard {\r\n        return new ViewCard(new Pos2D((this.CARD_WIDTH + 5) * (col) + this.xOffset(row, pyramidHeight),\r\n            (this.CARD_HEIGHT - 10) * (row ) + 20), new Pos2D(row, col), <string>label, false);\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a view card to represent a card in the draw pile with the given label and\r\n     * index.\r\n     *\r\n     * @param label the label of the card to be created\r\n     * @param index the index of the card to be created\r\n     * @return the view card with the given attributes to represent a draw card.\r\n     */\r\n    private createDrawViewCard(label: String, index: number): ViewCard {\r\n        return new ViewCard(new Pos2D(index * (this.CARD_WIDTH + 5) + 20,\r\n            515), new Pos2D(index, -1), <string>label, true);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset in the x plane to be used when positioning cards in the pyramid for the screen position.\r\n     *\r\n     * @param row           the row of the card being positioned\r\n     * @param pyramidHeight the height of the pyramid in rows\r\n     * @return the xOffset to be using in positioning a card in the given row in a pyramid of the given height.\r\n     */\r\n    private xOffset(row: number, pyramidHeight: number): number {\r\n        return (pyramidHeight - row - 1) * (this.CARD_WIDTH + 5) / 2 + 115;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given list of pyramid positions contains a position of a draw card.\r\n     *\r\n     * @param positions the positions to be checked\r\n     * @return whether the given positions contain the position of a draw card\r\n     */\r\n    private containsDrawCard(positions: Array<Pos2D>): boolean {\r\n        for (let index = 0; index < positions.length; index++) {\r\n            if (positions[index].getY() == -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given positions represent a valid pairing of cards, meaning the cards\r\n     * do not contain more than one draw card, which would be an illegal move.\r\n     *\r\n     * @param positions the positions in the pyramid of the cards being checked.\r\n     * @return whether the cards with the given positions are a valid pairing and can be removed together.\r\n     */\r\n    private validCards(positions: Array<Pos2D>): boolean {\r\n        let drawCardsCount: number = 0;\r\n        for (let index = 0; index < positions.length; index++) {\r\n            if (positions[index].getY() == -1) {\r\n                drawCardsCount++;\r\n            }\r\n        }\r\n        return drawCardsCount <= 1;\r\n    }\r\n\r\n    /**\r\n     * Discards a drawCard in the model and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the drawCard.\r\n     */\r\n    private discardDraw(cardPositions: Array<Pos2D>): void {\r\n        try {\r\n            this.model.discardDraw(cardPositions[0].getX());\r\n        } catch (e) {\r\n            this.view.deselect(cardPositions);\r\n        }\r\n        this.view.updateDraws(cardPositions[0], this.model.getDrawCards());\r\n    }\r\n\r\n    /**\r\n     * Discards the given cards including a drawCard and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the cards to be discarded.\r\n     */\r\n    private removeWithDraw(cardPositions: Array<Pos2D>): void {\r\n        let drawCard: Pos2D = null;\r\n        let nonDrawCard: Pos2D = null;\r\n        // finds he position representing the draw and non-draw cards\r\n        for (let index = 0; index < cardPositions.length; index++) {\r\n            if (cardPositions[index].getY() === -1) {\r\n                drawCard = cardPositions[index];\r\n            } else {\r\n                nonDrawCard = cardPositions[index];\r\n            }\r\n        }\r\n\r\n            this.model.removeUsingDraw(drawCard.getX(), nonDrawCard.getX(), nonDrawCard.getY());\r\n            this.view.updateDraws(drawCard, this.model.getDrawCards());\r\n\r\n    }\r\n\r\n    /**\r\n     * Discards the given cards not including a drawCard and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the cards to be discarded.\r\n     */\r\n    private removeWithoutDraw(cardPositions: Array<Pos2D>): void {\r\n        if (cardPositions.length == 1) { // if we are removing one card\r\n            this.model.remove(cardPositions[0].getX(), cardPositions[0].getY());\r\n        } else { // if we are removing two cards\r\n            this.model.removeTwo(cardPositions[0].getX(), cardPositions[0].getY(),\r\n                cardPositions[1].getX(), cardPositions[1].getY());\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","import React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport CSS from \"csstype\";\r\nimport {BasicPyramidSolitaire} from \"./BasicPyramidSolitaire\";\r\nimport {PyramidSolitaireVisualView} from \"./PyramidSolitaireVisualView\";\r\nimport {PyramidSolitaireVisualController} from \"./PyramidSolitaireVisualController\";\r\n\r\nclass App extends React.Component<{ }, { }> {\r\n\r\n\r\n  componentDidMount() {\r\n    const canvas = document.getElementById(\"myCanvas\");\r\n    const removeButton = document.getElementById(\"removeButton\");\r\n    const rulesButton = document.getElementById(\"rulesButton\");\r\n    // creates the model for the game\r\n    const model: BasicPyramidSolitaire = new BasicPyramidSolitaire();\r\n    // creates the view for the game\r\n    const view: PyramidSolitaireVisualView = new PyramidSolitaireVisualView(canvas, removeButton, rulesButton);\r\n    // creates the controller for the game\r\n    const visualController: PyramidSolitaireVisualController = new PyramidSolitaireVisualController(view, model);\r\n    visualController.playGame(model.getDeck(), false, 7, 3);\r\n\r\n  }\r\n\r\n  reshuffle() {\r\n    const canvas = document.getElementById(\"myCanvas\");\r\n    const removeButton = document.getElementById(\"removeButton\");\r\n    const rulesButton = document.getElementById(\"rulesButton\");\r\n    // creates the model for the game\r\n    const model: BasicPyramidSolitaire = new BasicPyramidSolitaire();\r\n    // creates the view for the game\r\n    const view: PyramidSolitaireVisualView = new PyramidSolitaireVisualView(canvas, removeButton, rulesButton);\r\n    // creates the controller for the game\r\n    const visualController: PyramidSolitaireVisualController = new PyramidSolitaireVisualController(view, model);\r\n    visualController.playGame(model.getDeck(), true, 7, 3);\r\n  }\r\n\r\n  render() {\r\n    const cnvStyle : CSS.Properties = {\r\n      border:\"1px solid #942222\",\r\n      marginTop: \"0.5em\"\r\n    }\r\n    const rmvButtonStyle : CSS.Properties = {\r\n      marginTop: \"0.5em\",\r\n      marginLeft: \"9.0em\",\r\n      backgroundColor: \"#013e04\",\r\n      color: \"white\",\r\n      fontSize: \"18px\",\r\n      fontFamily: \"veranda\"\r\n    }\r\n    const rulesAndShuffleButtonStyle : CSS.Properties = {\r\n      marginTop: \"0.5em\",\r\n      marginLeft: \"0.5em\",\r\n      backgroundColor: \"#013e04\",\r\n      color: \"white\",\r\n      fontSize: \"18px\",\r\n      fontFamily: \"veranda\"\r\n    }\r\n    return (<div>\r\n\r\n      <header>\r\n        <button type=\"button\" id = \"removeButton\" style={rmvButtonStyle}>Remove Selected</button>\r\n        <button type=\"button\" id = \"rulesButton\" style={rulesAndShuffleButtonStyle}>Rules</button>\r\n        <button type=\"button\" id = \"shuffleButton\" style={rulesAndShuffleButtonStyle} onClick={this.reshuffle}>New Shuffle</button>\r\n      </header>\r\n      <canvas id=\"myCanvas\" width=\"700\" height=\"800\" style = {cnvStyle}>\r\n      </canvas>\r\n    </div>);\r\n  }\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}