[{"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\index.tsx":"1","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\reportWebVitals.ts":"2","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\App.tsx":"3","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\BasicPyramidSolitaire.ts":"4","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualView.ts":"5","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualController.ts":"6","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\ViewCard.ts":"7","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractSinglePyramidSolitaireModel.ts":"8","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Pos2D.ts":"9","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Card.ts":"10","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractPyramidSolitaire.ts":"11","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Suit.ts":"12","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\GameState.ts":"13"},{"size":500,"mtime":499162500000,"results":"14","hashOfConfig":"15"},{"size":425,"mtime":499162500000,"results":"16","hashOfConfig":"15"},{"size":1978,"mtime":1609868851663,"results":"17","hashOfConfig":"15"},{"size":1546,"mtime":1609636653293,"results":"18","hashOfConfig":"15"},{"size":11810,"mtime":1610167005658,"results":"19","hashOfConfig":"15"},{"size":9363,"mtime":1610166336442,"results":"20","hashOfConfig":"15"},{"size":5044,"mtime":1609959703602,"results":"21","hashOfConfig":"15"},{"size":3787,"mtime":1609699671018,"results":"22","hashOfConfig":"15"},{"size":1316,"mtime":1609635373496,"results":"23","hashOfConfig":"15"},{"size":1676,"mtime":1609636015819,"results":"24","hashOfConfig":"15"},{"size":25357,"mtime":1610166075025,"results":"25","hashOfConfig":"15"},{"size":313,"mtime":1609636000485,"results":"26","hashOfConfig":"15"},{"size":294,"mtime":1609636533321,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"dx8lip",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"30"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"30"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"41","messages":"42","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"30"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"30"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"30"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"30"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"30"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\index.tsx",[],["62","63"],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\reportWebVitals.ts",[],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\App.tsx",["64"],"import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport CSS from \"csstype\";\nimport {BasicPyramidSolitaire} from \"./BasicPyramidSolitaire\";\nimport {PyramidSolitaireVisualView} from \"./PyramidSolitaireVisualView\";\nimport {PyramidSolitaireVisualController} from \"./PyramidSolitaireVisualController\";\n\nclass App extends React.Component<{ }, { }> {\n\n  componentDidMount() {\n    const canvas = document.getElementById(\"myCanvas\");\n    const removeButton = document.getElementById(\"removeButton\");\n    const rulesButton = document.getElementById(\"rulesButton\");\n    // creates the model for the game\n    const model: BasicPyramidSolitaire = new BasicPyramidSolitaire();\n    // creates the view for the game\n    const view: PyramidSolitaireVisualView = new PyramidSolitaireVisualView(canvas, removeButton, rulesButton);\n    // creates the controller for the game\n    const visualController: PyramidSolitaireVisualController = new PyramidSolitaireVisualController(view, model);\n    visualController.playGame(model.getDeck(), false, 7, 3);\n\n  }\n\n  render() {\n    const cnvStyle : CSS.Properties = {\n      border:\"1px solid #942222\",\n      marginTop: \"0.5em\"\n    }\n    const rmvButtonStyle : CSS.Properties = {\n      marginTop: \"0.5em\",\n      marginLeft: \"12.0em\",\n      backgroundColor: \"#013e04\",\n      color: \"white\",\n      fontSize: \"18px\",\n      fontFamily: \"veranda\"\n    }\n    const rulesButtonStyle : CSS.Properties = {\n      marginTop: \"0.5em\",\n      marginLeft: \"0.5em\",\n      backgroundColor: \"#013e04\",\n      color: \"white\",\n      fontSize: \"18px\",\n      fontFamily: \"veranda\"\n    }\n    return (<div>\n\n      <header>\n        <button type=\"button\" id = \"removeButton\" style={rmvButtonStyle}>Remove Selected</button>\n        <button type=\"button\" id = \"rulesButton\" style={rulesButtonStyle}>Rules</button>\n      </header>\n      <canvas id=\"myCanvas\" width=\"700\" height=\"800\" style = {cnvStyle}>\n      </canvas>\n    </div>);\n  }\n}\n\nexport default App;\n","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\BasicPyramidSolitaire.ts",["65"],"import {Card} from \"./Card\";\r\nimport {AbstractSinglePyramidSolitaireModel} from \"./AbstractSinglePyramidSolitaireModel\";\r\n\r\n/**\r\n * Represents the model of a game of pyramid solitaire, which is a game of solitaire in which the\r\n * cards are dealt into a pyramid shaped arrangement before playing. Holds all of the functionality\r\n * for the game including the dealing of cards, removal of cards, and the discarding of cards based\r\n * on the rules of this game.\r\n * <p> Cards may be removed in singles or as pairs with one card being from the pyramid of\r\n * cards and one being from the draw cards, or both cards being from the pyramid. The goal of the\r\n * game is to remove as many cards as possible, because to win the game all cards must be removed.\r\n * The game ends when there are no more possible removals, no more draws which can be discarded, or\r\n * the game has been won. </p>\r\n */\r\nexport class BasicPyramidSolitaire extends AbstractSinglePyramidSolitaireModel {\r\n\r\n    /**\r\n     * Constructs a {@code BasicPyramidSolitaire} object.\r\n     */\r\n    constructor() {\r\n        // instantiates GameStart to be not yet started.\r\n        super();\r\n    }\r\n\r\n    getPyramid(): Array<Array<Card>> {\r\n        let result: Array<Array<Card>> = new Array<Array<Card>>();\r\n        this.pyramid.forEach(function (row) {\r\n            let rowCopy: Array<Card> = new Array<Card>();\r\n            row.forEach(function (card) {\r\n                rowCopy.push(card);\r\n            })\r\n            result.push(rowCopy);\r\n        })\r\n        return result;\r\n    }\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualView.ts",["66","67","68","69","70","71"],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualController.ts",["72","73","74","75","76","77"],"import {Pos2D} from \"./Pos2D\";\r\nimport {ViewCard} from \"./ViewCard\";\r\nimport {Card} from \"./Card\";\r\nimport {BasicPyramidSolitaire} from \"./BasicPyramidSolitaire\";\r\nimport {PyramidSolitaireVisualView} from \"./PyramidSolitaireVisualView\";\r\n\r\n/**\r\n * Represents the controller for the visual version of pyramid solitaire.\r\n * Communicates between the view and the model to allow for the interactive playing of the game.\r\n */\r\nexport class PyramidSolitaireVisualController {\r\n    private view: PyramidSolitaireVisualView;\r\n    private model: BasicPyramidSolitaire;\r\n    readonly CARD_WIDTH = 60;\r\n    readonly CARD_HEIGHT = 70;\r\n\r\n    /**\r\n     * Constructs a PyramidSolitaireVisualController object with the given view and model.\r\n     * @param view the view\r\n     * @param model the model\r\n     */\r\n    constructor(view: PyramidSolitaireVisualView, model: BasicPyramidSolitaire) {\r\n        this.view = view;\r\n        this.model = model;\r\n    }\r\n\r\n    /**\r\n     * Runs a visual game of pyramid solitaire with the given deck and pyramid attributes.\r\n     * @param deck the deck to be used in the game\r\n     * @param shuffle whether or not the deck should be shuffled prior to plau\r\n     * @param numRows the number of rows in the given pyramid\r\n     * @param numDraw the number of draw cards to be used\r\n     */\r\n    playGame(deck: Array<Card>, shuffle: boolean, numRows: number, numDraw: number): void {\r\n        // starts the game in the model and starts the interaction in the view\r\n        this.model.startGame(deck, shuffle, numRows, numDraw);\r\n        console.log(this.model.getPyramid().length);\r\n\r\n        this.view.beginInteraction(this);\r\n\r\n        // creates viewCards for every card in the model\r\n        const pyramid: Array<Array<Card>>  = this.model.getPyramid(); // is const okay\r\n        console.log(pyramid);\r\n        for (let row = 0; row < pyramid.length; row++) {\r\n            for (let col = 0; col < pyramid[row].length; col++) {\r\n               // console.log(row +\" \"+ col);\r\n               this.view.drawCard(\r\n                   this.createPyramidViewCard(pyramid[row][col].toString(), row, col, pyramid.length));\r\n\r\n            }\r\n        }\r\n\r\n        const drawCards: Array<Card> = this.model.getDrawCards();\r\n\r\n        // creates viewCards for every drawCard in the model\r\n        for (let index = 0; index < drawCards.length; index++) {\r\n           this.view.drawCard(this.createDrawViewCard(drawCards[index].toString(), index));\r\n        }\r\n        // updates the score and refreshes the view.\r\n        this.view.updateScore(this.model.getScore());\r\n        this.view.refresh();\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Removes the cards in the pyramid with the given positions if possible.\r\n     * @param cardPositions the positions of the cards being attempted to be removed\r\n     */\r\n    removeSelected(cardPositions: Array<Pos2D>): void {\r\n        if (this.validCards(cardPositions)) {\r\n\r\n            if (cardPositions.length == 1 && this.containsDrawCard(cardPositions)) {\r\n                this.discardDraw(cardPositions);\r\n            } else {\r\n\r\n                try {\r\n                    if (this.containsDrawCard(cardPositions)) {\r\n                        this.removeWithDraw(cardPositions);\r\n                    } else {\r\n                        this.removeWithoutDraw(cardPositions);\r\n                    }\r\n\r\n                    // makes the cards removed from the pyramid invisible\r\n                    for (let index = 0 ; index < cardPositions.length ; index++) {\r\n                        this.view.makeInvisible(cardPositions[index]);\r\n                    }\r\n                } catch (e) {\r\n                    // deselects the cards if they cannot be removed\r\n                    this.view.deselect(cardPositions);\r\n\r\n                }\r\n            }\r\n        } else {\r\n            // deselects the cards if they are an invalid pairing (2 draw cards)\r\n            this.view.deselect(cardPositions);\r\n        }\r\n        // updates the score and refreshes the view\r\n        this.view.updateScore(this.model.getScore());\r\n        this.view.refresh();\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a view card representing a card in the pyramid of the game at the given row\r\n     * col index with the given label within a pyramid of the given height.\r\n     *\r\n     * @param label         the label of the card to be created\r\n     * @param row           the row of the card the returned view card is representing\r\n     * @param col           the column of the card the returned view card is representing\r\n     * @param pyramidHeight the height of the pyramid in which the view card is being created (in rows)\r\n     * @return a view card representing a card with the given attributes within a pyramid of the given height.\r\n     */\r\n    private createPyramidViewCard(label: String, row: number, col: number, pyramidHeight: number): ViewCard {\r\n        return new ViewCard(new Pos2D((this.CARD_WIDTH + 5) * (col) + this.xOffset(row, pyramidHeight),\r\n            (this.CARD_HEIGHT - 10) * (row ) + 20), new Pos2D(row, col), <string>label, false);\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a view card to represent a card in the draw pile with the given label and\r\n     * index.\r\n     *\r\n     * @param label the label of the card to be created\r\n     * @param index the index of the card to be created\r\n     * @return the view card with the given attributes to represent a draw card.\r\n     */\r\n    private createDrawViewCard(label: String, index: number): ViewCard {\r\n        return new ViewCard(new Pos2D(index * (this.CARD_WIDTH + 5) + 20,\r\n            525), new Pos2D(index, -1), <string>label, true);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset in the x plane to be used when positioning cards in the pyramid for the screen position.\r\n     *\r\n     * @param row           the row of the card being positioned\r\n     * @param pyramidHeight the height of the pyramid in rows\r\n     * @return the xOffset to be using in positioning a card in the given row in a pyramid of the given height.\r\n     */\r\n    private xOffset(row: number, pyramidHeight: number): number {\r\n        return (pyramidHeight - row - 1) * (this.CARD_WIDTH + 5) / 2 + 115;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given list of pyramid positions contains a position of a draw card.\r\n     *\r\n     * @param positions the positions to be checked\r\n     * @return whether the given positions contain the position of a draw card\r\n     */\r\n    private containsDrawCard(positions: Array<Pos2D>): boolean {\r\n        for (let index = 0; index < positions.length; index++) {\r\n            if (positions[index].getY() == -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given positions represent a valid pairing of cards, meaning the cards\r\n     * do not contain more than one draw card, which would be an illegal move.\r\n     *\r\n     * @param positions the positions in the pyramid of the cards being checked.\r\n     * @return whether the cards with the given positions are a valid pairing and can be removed together.\r\n     */\r\n    private validCards(positions: Array<Pos2D>): boolean {\r\n        let drawCardsCount: number = 0;\r\n        for (let index = 0; index < positions.length; index++) {\r\n            if (positions[index].getY() == -1) {\r\n                drawCardsCount++;\r\n            }\r\n        }\r\n        return drawCardsCount <= 1;\r\n    }\r\n\r\n    /**\r\n     * Discards a drawCard in the model and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the drawCard.\r\n     */\r\n    private discardDraw(cardPositions: Array<Pos2D>): void {\r\n        try {\r\n            this.model.discardDraw(cardPositions[0].getX());\r\n        } catch (e) {\r\n            this.view.deselect(cardPositions);\r\n        }\r\n        this.view.updateDraws(cardPositions[0], this.model.getDrawCards());\r\n    }\r\n\r\n    /**\r\n     * Discards the given cards including a drawCard and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the cards to be discarded.\r\n     */\r\n    private removeWithDraw(cardPositions: Array<Pos2D>): void {\r\n        let drawCard: Pos2D = null;\r\n        let nonDrawCard: Pos2D = null;\r\n        // finds he position representing the draw and non-draw cards\r\n        for (let index = 0; index < cardPositions.length; index++) {\r\n            if (cardPositions[index].getY() === -1) {\r\n                drawCard = cardPositions[index];\r\n            } else {\r\n                nonDrawCard = cardPositions[index];\r\n            }\r\n        }\r\n\r\n            this.model.removeUsingDraw(drawCard.getX(), nonDrawCard.getX(), nonDrawCard.getY());\r\n            this.view.updateDraws(drawCard, this.model.getDrawCards());\r\n\r\n    }\r\n\r\n    /**\r\n     * Discards the given cards not including a drawCard and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the cards to be discarded.\r\n     */\r\n    private removeWithoutDraw(cardPositions: Array<Pos2D>): void {\r\n        if (cardPositions.length == 1) { // if we are removing one card\r\n            this.model.remove(cardPositions[0].getX(), cardPositions[0].getY());\r\n        } else { // if we are removing two cards\r\n            this.model.removeTwo(cardPositions[0].getX(), cardPositions[0].getY(),\r\n                cardPositions[1].getX(), cardPositions[1].getY());\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\ViewCard.ts",["78","79","80","81"],"import {Pos2D} from \"./Pos2D\";\r\n\r\n/**\r\n * Represents a drawable card for a visual view of a game of solitaire.\r\n */\r\nexport class ViewCard {\r\n    private selected: boolean;\r\n    private visible: boolean;\r\n    private screenPos: Pos2D;\r\n    private pyramidPos: Pos2D;\r\n    private label: String;\r\n    private readonly isDrawCard: boolean;\r\n    readonly CARD_WIDTH = 60;\r\n    readonly CARD_HEIGHT = 70;\r\n\r\n    /**\r\n     * Creates a viewCard object with the given attributes.\r\n     * @param screenPos the position of the card on the screen.\r\n     * @param pyramidPos the position of the card in the pyramid.\r\n     * @param label the label of the card.\r\n     * @param isDrawCard whether the card to be created is a drawCard.\r\n     */\r\n    constructor(screenPos: Pos2D, pyramidPos: Pos2D, label: string, isDrawCard: boolean) {\r\n        this.selected = false;\r\n        this.visible = true;\r\n        this.screenPos = screenPos;\r\n        this.pyramidPos = pyramidPos;\r\n        this.label = label;\r\n        this.isDrawCard = isDrawCard;\r\n    }\r\n\r\n\r\n    /**\r\n     * Renders this viewCard with the given graphics.\r\n     *\r\n     * @param context the graphics to be rendered with.\r\n     */\r\n    render(context: CanvasRenderingContext2D): void {\r\n        context.font = \"25px Veranda\"\r\n        if (this.visible) { // if the card is visible\r\n            if (this.selected) { // if the card is selected\r\n                // renders the card\r\n                context.fillStyle = \"#65b577\";\r\n                context.fillRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // renders the accents and label\r\n                context.fillStyle = \"#064112\";\r\n                context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // might need to add font styling here\r\n\r\n                context.fillText(<string>this.label, this.screenPos.getX() + this.CARD_WIDTH / 4,\r\n                    this.screenPos.getY() + this.CARD_HEIGHT / 2);\r\n\r\n            } else { // if the card is not selected\r\n                // renders the card\r\n                context.fillStyle = \"#ffffff\";\r\n                context.fillRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // renders the accents and label\r\n                if (this.redSuit(this.label)) {\r\n                    context.fillStyle = \"#ef0707\";\r\n                } else {\r\n                    context.fillStyle = \"#000000\";\r\n                }\r\n                context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // might need to add font styling here\r\n                context.fillText(<string>this.label, this.screenPos.getX() + this.CARD_WIDTH / 4,\r\n                    this.screenPos.getY() + this.CARD_HEIGHT / 2);\r\n            }\r\n        } else { // if the card is not visible\r\n            if (this.redSuit(this.label)) {\r\n                context.fillStyle = \"#ef0707\";\r\n            } else {\r\n                context.fillStyle = \"#000000\";\r\n            }\r\n            context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                this.CARD_WIDTH, this.CARD_HEIGHT);\r\n\r\n        }\r\n    }\r\n\r\n    setSelected(selected: boolean): void {\r\n        this.selected = selected;\r\n    }\r\n\r\n    setVisible(visible: boolean): void {\r\n        this.visible = visible;\r\n    }\r\n\r\n    setPyramidPosition(pyramidPosition: Pos2D): void {\r\n        this.pyramidPos = pyramidPosition;\r\n    }\r\n\r\n    setLabel(label: string): void {\r\n        // checks if the given label is null\r\n        if (label == null) {\r\n            throw new Error(\"The given label cannot be null.\");\r\n        }\r\n        this.label = label;\r\n    }\r\n\r\n    getScreenPosition(): Pos2D {\r\n        // returns copy to disallow mutation\r\n        return new Pos2D(this.screenPos.getX(), this.screenPos.getY());\r\n    }\r\n\r\n    getPyramidPosition(): Pos2D {\r\n        // returns copy to disallow mutation\r\n        return new Pos2D(this.pyramidPos.getX(), this.pyramidPos.getY());\r\n    }\r\n\r\n    getSelected(): boolean {\r\n        return this.selected;\r\n    }\r\n\r\n    getVisible(): boolean {\r\n        return this.visible;\r\n    }\r\n\r\n    getLabel(): String {\r\n        return this.label;\r\n    }\r\n\r\n    isDrawCardCheck(): boolean {\r\n        return this.isDrawCard;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the card in the form of a string, one of: \"♥\", \"♠\", \"♣\", \"♦\".\r\n     * @param card the card whose type will be returned.\r\n     * @return the type of the card in the form of a string.\r\n     */\r\n    private suitType(card: ViewCard): string {\r\n        return card.getLabel().substring(card.getLabel().length-1);\r\n    }\r\n\r\n    private redSuit(type: String): boolean {\r\n        return (type.substring(type.length-1).localeCompare(\"♥\") == 0 ||\r\n            type.substring(type.length-1).localeCompare(\"♦\") == 0);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractSinglePyramidSolitaireModel.ts",["82","83"],"import {AbstractPyramidSolitaire} from \"./AbstractPyramidSolitaire\";\r\nimport {Card} from \"./Card\";\r\nimport {Suit} from \"./Suit\";\r\n\r\n/**\r\n * Represents the abstract functionality for a game of PyramidSolitaire, specifically the\r\n * functionality for games with boards in the shape of a single pyramid.\r\n */\r\nexport abstract class AbstractSinglePyramidSolitaireModel extends AbstractPyramidSolitaire {\r\n\r\n    /**\r\n     * Return a valid and complete deck of cards for a game of Pyramid Solitaire. There is no\r\n     * restriction imposed on the ordering of these cards in the deck. The validity of the deck is\r\n     * determined by the rules of the specific game in the classes implementing this interface.\r\n     *\r\n     * @return the deck of cards as a list\r\n     */\r\n    getDeck(): Array<Card> {\r\n        let deck: Array<Card> = new Array<Card>();\r\n        // creates an array containing all of the suits\r\n        let suits: Array<Suit> = new Array<Suit>();\r\n        suits.push(Suit.HEART);\r\n        suits.push(Suit.SPADE);\r\n        suits.push(Suit.CLUB);\r\n        suits.push(Suit.DIAMOND);\r\n        // Creates cards with every value and suit\r\n        suits.forEach(function(suit){\r\n            for (let x = 1; x < 14; x++) {\r\n                deck.push(new Card(suit, x));\r\n            }\r\n        });\r\n        return deck;\r\n    }\r\n\r\n    protected dealCards(numRows: number, deck: Array<Card>, shuffle:boolean) {\r\n        let result: Array<Array<Card>> = new Array<Array<Card>>();\r\n\r\n        // iterates over all the row indexes and creates rows for them\r\n        for (let rowIndex = 0; rowIndex < numRows; rowIndex += 1) {\r\n            let row: Array<Card> = new Array<Card>();\r\n            result.push(row);\r\n        }\r\n\r\n        // shuffles the deck if indicated\r\n        if (shuffle) {\r\n            this.shuffle(deck);\r\n        }\r\n\r\n        // adds all the cards necessary for a pyramid of the given size to the result from the deck\r\n        for (let row = 0; row < numRows; row += 1) {\r\n            for (let card = 0; card <= row; card += 1) {\r\n                result[row].push(deck[0]);\r\n                deck.shift();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    protected isValidDeck(deck: Array<Card>): boolean {\r\n        // iterates over every possible pairing of the cards in the given deck to check for\r\n        // duplicates.\r\n        for (let index = 0; index < deck.length; index += 1) {\r\n            for (let jindex = 0; jindex < deck.length; jindex += 1) {\r\n                if (index != jindex && deck[index].equals(deck[jindex])) {\r\n                    return false;\r\n                }\r\n\r\n            }\r\n            // checks if any card in the given deck is null\r\n            if (deck[index] == null) {\r\n                return false;\r\n            }\r\n        }\r\n        // checks that the given deck is of the same size as a valid deck for this game\r\n        return deck.length == this.getDeck().length;\r\n    }\r\n\r\n    protected isEnoughCards(deckSize: number, numRows: number, numDraws: number): boolean {\r\n        let pyramidSize: number = (numRows * (numRows + 1)) / 2;\r\n        return pyramidSize + numDraws <= deckSize;\r\n    }\r\n\r\n    shuffle(array: Array<any>): Array<any> {\r\n        var currentIndex = array.length, temporaryValue, randomIndex;\r\n\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Pos2D.ts",["84","85","86","87"],"/**\r\n * Represents an (x, y) position on the cartesian plane.\r\n */\r\nexport class Pos2D {\r\n    private readonly x: number;\r\n    private readonly y: number;\r\n\r\n    /**\r\n     * Creates a Pos2D object.\r\n     *\r\n     * @param x the x coordinate\r\n     * @param y the y coordinate\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Returns the x plane value of this position.\r\n     *\r\n     * @return the x plane coordinate of this position\r\n     */\r\n    getX(): number {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Returns the y plane value of this position.\r\n     *\r\n     * @return the y plan coordinate of this position\r\n     */\r\n    getY(): number {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Equality check for a given object and this Pos2D, returns true if the given object is a Pos2D,\r\n     * and all the attributes of the given Pos2D are the same as this pos.\r\n     * @param obj the object to be checked for equality with this one\r\n     */\r\n    equals(obj: any): boolean {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Pos2D)) {\r\n            return false;\r\n        }\r\n        let that: Pos2D = <Pos2D> obj;\r\n        return this.x == that.x\r\n            && this.y == that.y;\r\n    }\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Card.ts",["88","89","90","91","92","93","94","95"],"import {Suit} from \"./Suit\";\r\n\r\n/**\r\n * Represents a card in a standard deck of 52 with a suit and a value.\r\n */\r\nexport class Card {\r\n    private suit : Suit;\r\n    value : number;\r\n\r\n    /**\r\n     * Constructs a {@code Card} object.\r\n     *\r\n     * @param suit  the suit of the card\r\n     * @param value the numerical value of the card\r\n     */\r\n    constructor(suit:Suit, value:number) {\r\n        this.suit = suit;\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this card.\r\n     *\r\n     * @return the value field of this card\r\n     */\r\n    getValue(): number {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Equality check for a given object and this Card, returns true if the given object is a Card,\r\n     * and all the attributes of the given Card are the same as this card.\r\n     * @param obj the object to be checked for equality with this one\r\n     */\r\n    equals(obj: any): boolean {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Card)) {\r\n            return false;\r\n        }\r\n        let that : Card = <Card> obj;\r\n        return this.value == that.value &&\r\n            this.suit == that.suit;\r\n    }\r\n\r\n     toString(): string {\r\n        if (this.value == 1) {\r\n            return \"A\" + this.suit.toString();\r\n        } else if (this.value == 11) {\r\n            return \"J\" + this.suit.toString();\r\n        } else if (this.value == 12) {\r\n            return \"Q\" + this.suit.toString();\r\n        } else if (this.value == 13) {\r\n            return \"K\" + this.suit.toString();\r\n        } else {\r\n            return \"\" + this.value + this.suit.toString();\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractPyramidSolitaire.ts",["96","97","98","99","100","101","102","103","104","105","106","107"],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Suit.ts",[],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\GameState.ts",[],{"ruleId":"108","replacedBy":"109"},{"ruleId":"110","replacedBy":"111"},{"ruleId":"112","severity":1,"message":"113","line":2,"column":8,"nodeType":"114","messageId":"115","endLine":2,"endColumn":12},{"ruleId":"116","severity":1,"message":"117","line":20,"column":5,"nodeType":"118","messageId":"119","endLine":23,"endColumn":6},{"ruleId":"120","severity":1,"message":"121","line":26,"column":23,"nodeType":"122","messageId":"123","endLine":26,"endColumn":49},{"ruleId":"120","severity":1,"message":"121","line":28,"column":44,"nodeType":"122","messageId":"123","endLine":28,"endColumn":70},{"ruleId":"124","severity":1,"message":"125","line":66,"column":24,"nodeType":"126","messageId":"127","endLine":66,"endColumn":26},{"ruleId":"120","severity":1,"message":"128","line":154,"column":31,"nodeType":"122","messageId":"123","endLine":154,"endColumn":46},{"ruleId":"120","severity":1,"message":"128","line":229,"column":21,"nodeType":"122","messageId":"123","endLine":229,"endColumn":44},{"ruleId":"124","severity":1,"message":"125","line":265,"column":41,"nodeType":"126","messageId":"127","endLine":265,"endColumn":43},{"ruleId":"124","severity":1,"message":"125","line":73,"column":38,"nodeType":"126","messageId":"127","endLine":73,"endColumn":40},{"ruleId":"120","severity":1,"message":"128","line":116,"column":74,"nodeType":"122","messageId":"123","endLine":116,"endColumn":87},{"ruleId":"120","severity":1,"message":"128","line":129,"column":41,"nodeType":"122","messageId":"123","endLine":129,"endColumn":54},{"ruleId":"124","severity":1,"message":"125","line":151,"column":41,"nodeType":"126","messageId":"127","endLine":151,"endColumn":43},{"ruleId":"124","severity":1,"message":"125","line":168,"column":41,"nodeType":"126","messageId":"127","endLine":168,"endColumn":43},{"ruleId":"124","severity":1,"message":"125","line":217,"column":34,"nodeType":"126","messageId":"127","endLine":217,"endColumn":36},{"ruleId":"120","severity":1,"message":"128","line":52,"column":34,"nodeType":"122","messageId":"123","endLine":52,"endColumn":52},{"ruleId":"120","severity":1,"message":"128","line":69,"column":34,"nodeType":"122","messageId":"123","endLine":69,"endColumn":52},{"ruleId":"124","severity":1,"message":"125","line":140,"column":66,"nodeType":"126","messageId":"127","endLine":140,"endColumn":68},{"ruleId":"124","severity":1,"message":"125","line":141,"column":62,"nodeType":"126","messageId":"127","endLine":141,"endColumn":64},{"ruleId":"124","severity":1,"message":"129","line":65,"column":27,"nodeType":"126","messageId":"127","endLine":65,"endColumn":29},{"ruleId":"124","severity":1,"message":"125","line":76,"column":28,"nodeType":"126","messageId":"127","endLine":76,"endColumn":30},{"ruleId":"124","severity":1,"message":"125","line":43,"column":18,"nodeType":"126","messageId":"127","endLine":43,"endColumn":20},{"ruleId":"120","severity":1,"message":"130","line":49,"column":27,"nodeType":"122","messageId":"123","endLine":49,"endColumn":38},{"ruleId":"124","severity":1,"message":"125","line":50,"column":23,"nodeType":"126","messageId":"127","endLine":50,"endColumn":25},{"ruleId":"124","severity":1,"message":"125","line":51,"column":23,"nodeType":"126","messageId":"127","endLine":51,"endColumn":25},{"ruleId":"124","severity":1,"message":"125","line":36,"column":18,"nodeType":"126","messageId":"127","endLine":36,"endColumn":20},{"ruleId":"120","severity":1,"message":"131","line":42,"column":27,"nodeType":"122","messageId":"123","endLine":42,"endColumn":37},{"ruleId":"124","severity":1,"message":"125","line":43,"column":27,"nodeType":"126","messageId":"127","endLine":43,"endColumn":29},{"ruleId":"124","severity":1,"message":"125","line":44,"column":23,"nodeType":"126","messageId":"127","endLine":44,"endColumn":25},{"ruleId":"124","severity":1,"message":"125","line":48,"column":24,"nodeType":"126","messageId":"127","endLine":48,"endColumn":26},{"ruleId":"124","severity":1,"message":"125","line":50,"column":31,"nodeType":"126","messageId":"127","endLine":50,"endColumn":33},{"ruleId":"124","severity":1,"message":"125","line":52,"column":31,"nodeType":"126","messageId":"127","endLine":52,"endColumn":33},{"ruleId":"124","severity":1,"message":"125","line":54,"column":31,"nodeType":"126","messageId":"127","endLine":54,"endColumn":33},{"ruleId":"124","severity":1,"message":"125","line":67,"column":21,"nodeType":"126","messageId":"127","endLine":67,"endColumn":23},{"ruleId":"124","severity":1,"message":"125","line":67,"column":37,"nodeType":"126","messageId":"127","endLine":67,"endColumn":39},{"ruleId":"124","severity":1,"message":"129","line":160,"column":50,"nodeType":"126","messageId":"127","endLine":160,"endColumn":52},{"ruleId":"124","severity":1,"message":"129","line":209,"column":13,"nodeType":"126","messageId":"127","endLine":209,"endColumn":15},{"ruleId":"124","severity":1,"message":"125","line":263,"column":28,"nodeType":"126","messageId":"127","endLine":263,"endColumn":30},{"ruleId":"124","severity":1,"message":"125","line":278,"column":28,"nodeType":"126","messageId":"127","endLine":278,"endColumn":30},{"ruleId":"124","severity":1,"message":"125","line":437,"column":17,"nodeType":"126","messageId":"127","endLine":437,"endColumn":19},{"ruleId":"124","severity":1,"message":"125","line":523,"column":41,"nodeType":"126","messageId":"127","endLine":523,"endColumn":43},{"ruleId":"124","severity":1,"message":"129","line":541,"column":27,"nodeType":"126","messageId":"127","endLine":541,"endColumn":29},{"ruleId":"124","severity":1,"message":"125","line":542,"column":71,"nodeType":"126","messageId":"127","endLine":542,"endColumn":73},{"ruleId":"124","severity":1,"message":"125","line":575,"column":28,"nodeType":"126","messageId":"127","endLine":575,"endColumn":30},{"ruleId":"124","severity":1,"message":"129","line":621,"column":13,"nodeType":"126","messageId":"127","endLine":621,"endColumn":15},"no-native-reassign",["132"],"no-negated-in-lhs",["133"],"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","@typescript-eslint/consistent-type-assertions","Use 'as HTMLCanvasElement' instead of '<HTMLCanvasElement>'.","TSTypeAssertion","as","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Use 'as string' instead of '<string>'.","Expected '!==' and instead saw '!='.","Use 'as Pos2D' instead of '<Pos2D>'.","Use 'as Card' instead of '<Card>'.","no-global-assign","no-unsafe-negation"]