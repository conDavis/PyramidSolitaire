[{"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\index.tsx":"1","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\reportWebVitals.ts":"2","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\App.tsx":"3","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\BasicPyramidSolitaire.ts":"4","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualView.ts":"5","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualController.ts":"6","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\ViewCard.ts":"7","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractSinglePyramidSolitaireModel.ts":"8","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Pos2D.ts":"9","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Card.ts":"10","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractPyramidSolitaire.ts":"11","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Suit.ts":"12","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\GameState.ts":"13"},{"size":500,"mtime":499162500000,"results":"14","hashOfConfig":"15"},{"size":425,"mtime":499162500000,"results":"16","hashOfConfig":"15"},{"size":1978,"mtime":1609868851663,"results":"17","hashOfConfig":"15"},{"size":1546,"mtime":1609636653293,"results":"18","hashOfConfig":"15"},{"size":14668,"mtime":1612931441605,"results":"19","hashOfConfig":"15"},{"size":9363,"mtime":1610240059975,"results":"20","hashOfConfig":"15"},{"size":5044,"mtime":1609959703602,"results":"21","hashOfConfig":"15"},{"size":3787,"mtime":1609699671018,"results":"22","hashOfConfig":"15"},{"size":1316,"mtime":1609635373496,"results":"23","hashOfConfig":"15"},{"size":1676,"mtime":1609636015819,"results":"24","hashOfConfig":"15"},{"size":25357,"mtime":1610166075025,"results":"25","hashOfConfig":"15"},{"size":313,"mtime":1609636000485,"results":"26","hashOfConfig":"15"},{"size":294,"mtime":1609636533321,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"dx8lip",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"30"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"30"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"41","messages":"42","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"30"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"30"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"30"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"30"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"30"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"30"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\index.tsx",[],["63","64"],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\reportWebVitals.ts",[],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\App.tsx",["65"],"import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport CSS from \"csstype\";\nimport {BasicPyramidSolitaire} from \"./BasicPyramidSolitaire\";\nimport {PyramidSolitaireVisualView} from \"./PyramidSolitaireVisualView\";\nimport {PyramidSolitaireVisualController} from \"./PyramidSolitaireVisualController\";\n\nclass App extends React.Component<{ }, { }> {\n\n  componentDidMount() {\n    const canvas = document.getElementById(\"myCanvas\");\n    const removeButton = document.getElementById(\"removeButton\");\n    const rulesButton = document.getElementById(\"rulesButton\");\n    // creates the model for the game\n    const model: BasicPyramidSolitaire = new BasicPyramidSolitaire();\n    // creates the view for the game\n    const view: PyramidSolitaireVisualView = new PyramidSolitaireVisualView(canvas, removeButton, rulesButton);\n    // creates the controller for the game\n    const visualController: PyramidSolitaireVisualController = new PyramidSolitaireVisualController(view, model);\n    visualController.playGame(model.getDeck(), false, 7, 3);\n\n  }\n\n  render() {\n    const cnvStyle : CSS.Properties = {\n      border:\"1px solid #942222\",\n      marginTop: \"0.5em\"\n    }\n    const rmvButtonStyle : CSS.Properties = {\n      marginTop: \"0.5em\",\n      marginLeft: \"12.0em\",\n      backgroundColor: \"#013e04\",\n      color: \"white\",\n      fontSize: \"18px\",\n      fontFamily: \"veranda\"\n    }\n    const rulesButtonStyle : CSS.Properties = {\n      marginTop: \"0.5em\",\n      marginLeft: \"0.5em\",\n      backgroundColor: \"#013e04\",\n      color: \"white\",\n      fontSize: \"18px\",\n      fontFamily: \"veranda\"\n    }\n    return (<div>\n\n      <header>\n        <button type=\"button\" id = \"removeButton\" style={rmvButtonStyle}>Remove Selected</button>\n        <button type=\"button\" id = \"rulesButton\" style={rulesButtonStyle}>Rules</button>\n      </header>\n      <canvas id=\"myCanvas\" width=\"700\" height=\"800\" style = {cnvStyle}>\n      </canvas>\n    </div>);\n  }\n}\n\nexport default App;\n","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\BasicPyramidSolitaire.ts",["66"],"import {Card} from \"./Card\";\r\nimport {AbstractSinglePyramidSolitaireModel} from \"./AbstractSinglePyramidSolitaireModel\";\r\n\r\n/**\r\n * Represents the model of a game of pyramid solitaire, which is a game of solitaire in which the\r\n * cards are dealt into a pyramid shaped arrangement before playing. Holds all of the functionality\r\n * for the game including the dealing of cards, removal of cards, and the discarding of cards based\r\n * on the rules of this game.\r\n * <p> Cards may be removed in singles or as pairs with one card being from the pyramid of\r\n * cards and one being from the draw cards, or both cards being from the pyramid. The goal of the\r\n * game is to remove as many cards as possible, because to win the game all cards must be removed.\r\n * The game ends when there are no more possible removals, no more draws which can be discarded, or\r\n * the game has been won. </p>\r\n */\r\nexport class BasicPyramidSolitaire extends AbstractSinglePyramidSolitaireModel {\r\n\r\n    /**\r\n     * Constructs a {@code BasicPyramidSolitaire} object.\r\n     */\r\n    constructor() {\r\n        // instantiates GameStart to be not yet started.\r\n        super();\r\n    }\r\n\r\n    getPyramid(): Array<Array<Card>> {\r\n        let result: Array<Array<Card>> = new Array<Array<Card>>();\r\n        this.pyramid.forEach(function (row) {\r\n            let rowCopy: Array<Card> = new Array<Card>();\r\n            row.forEach(function (card) {\r\n                rowCopy.push(card);\r\n            })\r\n            result.push(rowCopy);\r\n        })\r\n        return result;\r\n    }\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualView.ts",["67","68","69","70","71","72"],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\PyramidSolitaireVisualController.ts",["73","74","75","76","77","78"],"import {Pos2D} from \"./Pos2D\";\r\nimport {ViewCard} from \"./ViewCard\";\r\nimport {Card} from \"./Card\";\r\nimport {BasicPyramidSolitaire} from \"./BasicPyramidSolitaire\";\r\nimport {PyramidSolitaireVisualView} from \"./PyramidSolitaireVisualView\";\r\n\r\n/**\r\n * Represents the controller for the visual version of pyramid solitaire.\r\n * Communicates between the view and the model to allow for the interactive playing of the game.\r\n */\r\nexport class PyramidSolitaireVisualController {\r\n    private view: PyramidSolitaireVisualView;\r\n    private model: BasicPyramidSolitaire;\r\n    readonly CARD_WIDTH = 60;\r\n    readonly CARD_HEIGHT = 70;\r\n\r\n    /**\r\n     * Constructs a PyramidSolitaireVisualController object with the given view and model.\r\n     * @param view the view\r\n     * @param model the model\r\n     */\r\n    constructor(view: PyramidSolitaireVisualView, model: BasicPyramidSolitaire) {\r\n        this.view = view;\r\n        this.model = model;\r\n    }\r\n\r\n    /**\r\n     * Runs a visual game of pyramid solitaire with the given deck and pyramid attributes.\r\n     * @param deck the deck to be used in the game\r\n     * @param shuffle whether or not the deck should be shuffled prior to plau\r\n     * @param numRows the number of rows in the given pyramid\r\n     * @param numDraw the number of draw cards to be used\r\n     */\r\n    playGame(deck: Array<Card>, shuffle: boolean, numRows: number, numDraw: number): void {\r\n        // starts the game in the model and starts the interaction in the view\r\n        this.model.startGame(deck, shuffle, numRows, numDraw);\r\n        console.log(this.model.getPyramid().length);\r\n\r\n        this.view.beginInteraction(this);\r\n\r\n        // creates viewCards for every card in the model\r\n        const pyramid: Array<Array<Card>>  = this.model.getPyramid(); // is const okay\r\n        console.log(pyramid);\r\n        for (let row = 0; row < pyramid.length; row++) {\r\n            for (let col = 0; col < pyramid[row].length; col++) {\r\n               // console.log(row +\" \"+ col);\r\n               this.view.drawCard(\r\n                   this.createPyramidViewCard(pyramid[row][col].toString(), row, col, pyramid.length));\r\n\r\n            }\r\n        }\r\n\r\n        const drawCards: Array<Card> = this.model.getDrawCards();\r\n\r\n        // creates viewCards for every drawCard in the model\r\n        for (let index = 0; index < drawCards.length; index++) {\r\n           this.view.drawCard(this.createDrawViewCard(drawCards[index].toString(), index));\r\n        }\r\n        // updates the score and refreshes the view.\r\n        this.view.updateScore(this.model.getScore());\r\n        this.view.refresh();\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Removes the cards in the pyramid with the given positions if possible.\r\n     * @param cardPositions the positions of the cards being attempted to be removed\r\n     */\r\n    removeSelected(cardPositions: Array<Pos2D>): void {\r\n        if (this.validCards(cardPositions)) {\r\n\r\n            if (cardPositions.length == 1 && this.containsDrawCard(cardPositions)) {\r\n                this.discardDraw(cardPositions);\r\n            } else {\r\n\r\n                try {\r\n                    if (this.containsDrawCard(cardPositions)) {\r\n                        this.removeWithDraw(cardPositions);\r\n                    } else {\r\n                        this.removeWithoutDraw(cardPositions);\r\n                    }\r\n\r\n                    // makes the cards removed from the pyramid invisible\r\n                    for (let index = 0 ; index < cardPositions.length ; index++) {\r\n                        this.view.makeInvisible(cardPositions[index]);\r\n                    }\r\n                } catch (e) {\r\n                    // deselects the cards if they cannot be removed\r\n                    this.view.deselect(cardPositions);\r\n\r\n                }\r\n            }\r\n        } else {\r\n            // deselects the cards if they are an invalid pairing (2 draw cards)\r\n            this.view.deselect(cardPositions);\r\n        }\r\n        // updates the score and refreshes the view\r\n        this.view.updateScore(this.model.getScore());\r\n        this.view.refresh();\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a view card representing a card in the pyramid of the game at the given row\r\n     * col index with the given label within a pyramid of the given height.\r\n     *\r\n     * @param label         the label of the card to be created\r\n     * @param row           the row of the card the returned view card is representing\r\n     * @param col           the column of the card the returned view card is representing\r\n     * @param pyramidHeight the height of the pyramid in which the view card is being created (in rows)\r\n     * @return a view card representing a card with the given attributes within a pyramid of the given height.\r\n     */\r\n    private createPyramidViewCard(label: String, row: number, col: number, pyramidHeight: number): ViewCard {\r\n        return new ViewCard(new Pos2D((this.CARD_WIDTH + 5) * (col) + this.xOffset(row, pyramidHeight),\r\n            (this.CARD_HEIGHT - 10) * (row ) + 20), new Pos2D(row, col), <string>label, false);\r\n    }\r\n\r\n    /**\r\n     * Creates and returns a view card to represent a card in the draw pile with the given label and\r\n     * index.\r\n     *\r\n     * @param label the label of the card to be created\r\n     * @param index the index of the card to be created\r\n     * @return the view card with the given attributes to represent a draw card.\r\n     */\r\n    private createDrawViewCard(label: String, index: number): ViewCard {\r\n        return new ViewCard(new Pos2D(index * (this.CARD_WIDTH + 5) + 20,\r\n            515), new Pos2D(index, -1), <string>label, true);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset in the x plane to be used when positioning cards in the pyramid for the screen position.\r\n     *\r\n     * @param row           the row of the card being positioned\r\n     * @param pyramidHeight the height of the pyramid in rows\r\n     * @return the xOffset to be using in positioning a card in the given row in a pyramid of the given height.\r\n     */\r\n    private xOffset(row: number, pyramidHeight: number): number {\r\n        return (pyramidHeight - row - 1) * (this.CARD_WIDTH + 5) / 2 + 115;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given list of pyramid positions contains a position of a draw card.\r\n     *\r\n     * @param positions the positions to be checked\r\n     * @return whether the given positions contain the position of a draw card\r\n     */\r\n    private containsDrawCard(positions: Array<Pos2D>): boolean {\r\n        for (let index = 0; index < positions.length; index++) {\r\n            if (positions[index].getY() == -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given positions represent a valid pairing of cards, meaning the cards\r\n     * do not contain more than one draw card, which would be an illegal move.\r\n     *\r\n     * @param positions the positions in the pyramid of the cards being checked.\r\n     * @return whether the cards with the given positions are a valid pairing and can be removed together.\r\n     */\r\n    private validCards(positions: Array<Pos2D>): boolean {\r\n        let drawCardsCount: number = 0;\r\n        for (let index = 0; index < positions.length; index++) {\r\n            if (positions[index].getY() == -1) {\r\n                drawCardsCount++;\r\n            }\r\n        }\r\n        return drawCardsCount <= 1;\r\n    }\r\n\r\n    /**\r\n     * Discards a drawCard in the model and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the drawCard.\r\n     */\r\n    private discardDraw(cardPositions: Array<Pos2D>): void {\r\n        try {\r\n            this.model.discardDraw(cardPositions[0].getX());\r\n        } catch (e) {\r\n            this.view.deselect(cardPositions);\r\n        }\r\n        this.view.updateDraws(cardPositions[0], this.model.getDrawCards());\r\n    }\r\n\r\n    /**\r\n     * Discards the given cards including a drawCard and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the cards to be discarded.\r\n     */\r\n    private removeWithDraw(cardPositions: Array<Pos2D>): void {\r\n        let drawCard: Pos2D = null;\r\n        let nonDrawCard: Pos2D = null;\r\n        // finds he position representing the draw and non-draw cards\r\n        for (let index = 0; index < cardPositions.length; index++) {\r\n            if (cardPositions[index].getY() === -1) {\r\n                drawCard = cardPositions[index];\r\n            } else {\r\n                nonDrawCard = cardPositions[index];\r\n            }\r\n        }\r\n\r\n            this.model.removeUsingDraw(drawCard.getX(), nonDrawCard.getX(), nonDrawCard.getY());\r\n            this.view.updateDraws(drawCard, this.model.getDrawCards());\r\n\r\n    }\r\n\r\n    /**\r\n     * Discards the given cards not including a drawCard and updates the view.\r\n     *\r\n     * @param cardPositions the given positions of the cards to be discarded.\r\n     */\r\n    private removeWithoutDraw(cardPositions: Array<Pos2D>): void {\r\n        if (cardPositions.length == 1) { // if we are removing one card\r\n            this.model.remove(cardPositions[0].getX(), cardPositions[0].getY());\r\n        } else { // if we are removing two cards\r\n            this.model.removeTwo(cardPositions[0].getX(), cardPositions[0].getY(),\r\n                cardPositions[1].getX(), cardPositions[1].getY());\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\ViewCard.ts",["79","80","81","82"],"import {Pos2D} from \"./Pos2D\";\r\n\r\n/**\r\n * Represents a drawable card for a visual view of a game of solitaire.\r\n */\r\nexport class ViewCard {\r\n    private selected: boolean;\r\n    private visible: boolean;\r\n    private screenPos: Pos2D;\r\n    private pyramidPos: Pos2D;\r\n    private label: String;\r\n    private readonly isDrawCard: boolean;\r\n    readonly CARD_WIDTH = 60;\r\n    readonly CARD_HEIGHT = 70;\r\n\r\n    /**\r\n     * Creates a viewCard object with the given attributes.\r\n     * @param screenPos the position of the card on the screen.\r\n     * @param pyramidPos the position of the card in the pyramid.\r\n     * @param label the label of the card.\r\n     * @param isDrawCard whether the card to be created is a drawCard.\r\n     */\r\n    constructor(screenPos: Pos2D, pyramidPos: Pos2D, label: string, isDrawCard: boolean) {\r\n        this.selected = false;\r\n        this.visible = true;\r\n        this.screenPos = screenPos;\r\n        this.pyramidPos = pyramidPos;\r\n        this.label = label;\r\n        this.isDrawCard = isDrawCard;\r\n    }\r\n\r\n\r\n    /**\r\n     * Renders this viewCard with the given graphics.\r\n     *\r\n     * @param context the graphics to be rendered with.\r\n     */\r\n    render(context: CanvasRenderingContext2D): void {\r\n        context.font = \"25px Veranda\"\r\n        if (this.visible) { // if the card is visible\r\n            if (this.selected) { // if the card is selected\r\n                // renders the card\r\n                context.fillStyle = \"#65b577\";\r\n                context.fillRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // renders the accents and label\r\n                context.fillStyle = \"#064112\";\r\n                context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // might need to add font styling here\r\n\r\n                context.fillText(<string>this.label, this.screenPos.getX() + this.CARD_WIDTH / 4,\r\n                    this.screenPos.getY() + this.CARD_HEIGHT / 2);\r\n\r\n            } else { // if the card is not selected\r\n                // renders the card\r\n                context.fillStyle = \"#ffffff\";\r\n                context.fillRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // renders the accents and label\r\n                if (this.redSuit(this.label)) {\r\n                    context.fillStyle = \"#ef0707\";\r\n                } else {\r\n                    context.fillStyle = \"#000000\";\r\n                }\r\n                context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                    this.CARD_WIDTH, this.CARD_HEIGHT);\r\n                // might need to add font styling here\r\n                context.fillText(<string>this.label, this.screenPos.getX() + this.CARD_WIDTH / 4,\r\n                    this.screenPos.getY() + this.CARD_HEIGHT / 2);\r\n            }\r\n        } else { // if the card is not visible\r\n            if (this.redSuit(this.label)) {\r\n                context.fillStyle = \"#ef0707\";\r\n            } else {\r\n                context.fillStyle = \"#000000\";\r\n            }\r\n            context.strokeRect(this.screenPos.getX(), this.screenPos.getY(),\r\n                this.CARD_WIDTH, this.CARD_HEIGHT);\r\n\r\n        }\r\n    }\r\n\r\n    setSelected(selected: boolean): void {\r\n        this.selected = selected;\r\n    }\r\n\r\n    setVisible(visible: boolean): void {\r\n        this.visible = visible;\r\n    }\r\n\r\n    setPyramidPosition(pyramidPosition: Pos2D): void {\r\n        this.pyramidPos = pyramidPosition;\r\n    }\r\n\r\n    setLabel(label: string): void {\r\n        // checks if the given label is null\r\n        if (label == null) {\r\n            throw new Error(\"The given label cannot be null.\");\r\n        }\r\n        this.label = label;\r\n    }\r\n\r\n    getScreenPosition(): Pos2D {\r\n        // returns copy to disallow mutation\r\n        return new Pos2D(this.screenPos.getX(), this.screenPos.getY());\r\n    }\r\n\r\n    getPyramidPosition(): Pos2D {\r\n        // returns copy to disallow mutation\r\n        return new Pos2D(this.pyramidPos.getX(), this.pyramidPos.getY());\r\n    }\r\n\r\n    getSelected(): boolean {\r\n        return this.selected;\r\n    }\r\n\r\n    getVisible(): boolean {\r\n        return this.visible;\r\n    }\r\n\r\n    getLabel(): String {\r\n        return this.label;\r\n    }\r\n\r\n    isDrawCardCheck(): boolean {\r\n        return this.isDrawCard;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the card in the form of a string, one of: \"♥\", \"♠\", \"♣\", \"♦\".\r\n     * @param card the card whose type will be returned.\r\n     * @return the type of the card in the form of a string.\r\n     */\r\n    private suitType(card: ViewCard): string {\r\n        return card.getLabel().substring(card.getLabel().length-1);\r\n    }\r\n\r\n    private redSuit(type: String): boolean {\r\n        return (type.substring(type.length-1).localeCompare(\"♥\") == 0 ||\r\n            type.substring(type.length-1).localeCompare(\"♦\") == 0);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractSinglePyramidSolitaireModel.ts",["83","84"],"import {AbstractPyramidSolitaire} from \"./AbstractPyramidSolitaire\";\r\nimport {Card} from \"./Card\";\r\nimport {Suit} from \"./Suit\";\r\n\r\n/**\r\n * Represents the abstract functionality for a game of PyramidSolitaire, specifically the\r\n * functionality for games with boards in the shape of a single pyramid.\r\n */\r\nexport abstract class AbstractSinglePyramidSolitaireModel extends AbstractPyramidSolitaire {\r\n\r\n    /**\r\n     * Return a valid and complete deck of cards for a game of Pyramid Solitaire. There is no\r\n     * restriction imposed on the ordering of these cards in the deck. The validity of the deck is\r\n     * determined by the rules of the specific game in the classes implementing this interface.\r\n     *\r\n     * @return the deck of cards as a list\r\n     */\r\n    getDeck(): Array<Card> {\r\n        let deck: Array<Card> = new Array<Card>();\r\n        // creates an array containing all of the suits\r\n        let suits: Array<Suit> = new Array<Suit>();\r\n        suits.push(Suit.HEART);\r\n        suits.push(Suit.SPADE);\r\n        suits.push(Suit.CLUB);\r\n        suits.push(Suit.DIAMOND);\r\n        // Creates cards with every value and suit\r\n        suits.forEach(function(suit){\r\n            for (let x = 1; x < 14; x++) {\r\n                deck.push(new Card(suit, x));\r\n            }\r\n        });\r\n        return deck;\r\n    }\r\n\r\n    protected dealCards(numRows: number, deck: Array<Card>, shuffle:boolean) {\r\n        let result: Array<Array<Card>> = new Array<Array<Card>>();\r\n\r\n        // iterates over all the row indexes and creates rows for them\r\n        for (let rowIndex = 0; rowIndex < numRows; rowIndex += 1) {\r\n            let row: Array<Card> = new Array<Card>();\r\n            result.push(row);\r\n        }\r\n\r\n        // shuffles the deck if indicated\r\n        if (shuffle) {\r\n            this.shuffle(deck);\r\n        }\r\n\r\n        // adds all the cards necessary for a pyramid of the given size to the result from the deck\r\n        for (let row = 0; row < numRows; row += 1) {\r\n            for (let card = 0; card <= row; card += 1) {\r\n                result[row].push(deck[0]);\r\n                deck.shift();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    protected isValidDeck(deck: Array<Card>): boolean {\r\n        // iterates over every possible pairing of the cards in the given deck to check for\r\n        // duplicates.\r\n        for (let index = 0; index < deck.length; index += 1) {\r\n            for (let jindex = 0; jindex < deck.length; jindex += 1) {\r\n                if (index != jindex && deck[index].equals(deck[jindex])) {\r\n                    return false;\r\n                }\r\n\r\n            }\r\n            // checks if any card in the given deck is null\r\n            if (deck[index] == null) {\r\n                return false;\r\n            }\r\n        }\r\n        // checks that the given deck is of the same size as a valid deck for this game\r\n        return deck.length == this.getDeck().length;\r\n    }\r\n\r\n    protected isEnoughCards(deckSize: number, numRows: number, numDraws: number): boolean {\r\n        let pyramidSize: number = (numRows * (numRows + 1)) / 2;\r\n        return pyramidSize + numDraws <= deckSize;\r\n    }\r\n\r\n    shuffle(array: Array<any>): Array<any> {\r\n        var currentIndex = array.length, temporaryValue, randomIndex;\r\n\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Pos2D.ts",["85","86","87","88"],"/**\r\n * Represents an (x, y) position on the cartesian plane.\r\n */\r\nexport class Pos2D {\r\n    private readonly x: number;\r\n    private readonly y: number;\r\n\r\n    /**\r\n     * Creates a Pos2D object.\r\n     *\r\n     * @param x the x coordinate\r\n     * @param y the y coordinate\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Returns the x plane value of this position.\r\n     *\r\n     * @return the x plane coordinate of this position\r\n     */\r\n    getX(): number {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Returns the y plane value of this position.\r\n     *\r\n     * @return the y plan coordinate of this position\r\n     */\r\n    getY(): number {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Equality check for a given object and this Pos2D, returns true if the given object is a Pos2D,\r\n     * and all the attributes of the given Pos2D are the same as this pos.\r\n     * @param obj the object to be checked for equality with this one\r\n     */\r\n    equals(obj: any): boolean {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Pos2D)) {\r\n            return false;\r\n        }\r\n        let that: Pos2D = <Pos2D> obj;\r\n        return this.x == that.x\r\n            && this.y == that.y;\r\n    }\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Card.ts",["89","90","91","92","93","94","95","96"],"import {Suit} from \"./Suit\";\r\n\r\n/**\r\n * Represents a card in a standard deck of 52 with a suit and a value.\r\n */\r\nexport class Card {\r\n    private suit : Suit;\r\n    value : number;\r\n\r\n    /**\r\n     * Constructs a {@code Card} object.\r\n     *\r\n     * @param suit  the suit of the card\r\n     * @param value the numerical value of the card\r\n     */\r\n    constructor(suit:Suit, value:number) {\r\n        this.suit = suit;\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this card.\r\n     *\r\n     * @return the value field of this card\r\n     */\r\n    getValue(): number {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Equality check for a given object and this Card, returns true if the given object is a Card,\r\n     * and all the attributes of the given Card are the same as this card.\r\n     * @param obj the object to be checked for equality with this one\r\n     */\r\n    equals(obj: any): boolean {\r\n        if (this == obj) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Card)) {\r\n            return false;\r\n        }\r\n        let that : Card = <Card> obj;\r\n        return this.value == that.value &&\r\n            this.suit == that.suit;\r\n    }\r\n\r\n     toString(): string {\r\n        if (this.value == 1) {\r\n            return \"A\" + this.suit.toString();\r\n        } else if (this.value == 11) {\r\n            return \"J\" + this.suit.toString();\r\n        } else if (this.value == 12) {\r\n            return \"Q\" + this.suit.toString();\r\n        } else if (this.value == 13) {\r\n            return \"K\" + this.suit.toString();\r\n        } else {\r\n            return \"\" + this.value + this.suit.toString();\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\AbstractPyramidSolitaire.ts",["97","98","99","100","101","102","103","104","105","106","107","108"],"import {Card} from \"./Card\";\r\nimport {GameState} from \"./GameState\";\r\n\r\n/**\r\n * Represents the abstract functionality for a game of PyramidSolitaire, regardless of the number of\r\n * pyramids of the game.\r\n */\r\n export abstract class AbstractPyramidSolitaire {\r\n    protected pyramid: Array<Array<Card>>;\r\n    private stock: Array<Card>;\r\n    protected draws: Array<Card>;\r\n    protected gamestate: GameState;\r\n    protected removalValue: number = 13;\r\n\r\n    /**\r\n     * Constructs a {@code AbstractPyramidModel} object.\r\n     */\r\n    constructor() {\r\n        this.gamestate = GameState.NOT_STARTED;\r\n    }\r\n\r\n    /**\r\n     * Return a valid and complete deck of cards for a game of Pyramid Solitaire. There is no\r\n     * restriction imposed on the ordering of these cards in the deck. The validity of the deck is\r\n     * determined by the rules of the specific game in the classes implementing this interface.\r\n     *\r\n     * @return the deck of cards as a list\r\n     */\r\n    abstract getDeck(): Array<Card>;\r\n\r\n    /**\r\n     * <p>Deal a new game of Pyramid Solitaire.\r\n     * The cards to be used and their order are specified by the the given deck, unless the {@code\r\n     * shuffle} parameter indicates the order should be ignored.</p>\r\n     *\r\n     * <p>This method first verifies that the deck is valid. It deals cards in rows\r\n     * (left-to-right, top-to-bottom) into the characteristic pyramid shape with the specified number\r\n     * of rows, followed by the specified number of draw cards. When {@code shuffle} is {@code false},\r\n     * the 0th card in {@code deck} is used as the first card dealt.</p>\r\n     *\r\n     * <p>This method should have no other side effects, and should work for any valid arguments.</p>\r\n     *\r\n     * @param deck    the deck to be dealt\r\n     * @param shuffle if {@code false}, use the order as given by {@code deck}, otherwise use a\r\n     *                randomly shuffled order\r\n     * @param numRows number of rows in the pyramid\r\n     * @param numDraw number of draw cards available at a time\r\n     * @throws Error if the deck is null or invalid, the number of pyramid rows or\r\n     *                                  number of available draw cards is non-positive, or a full\r\n     *                                  pyramid and draw pile cannot be dealt with the number of given\r\n     *                                  cards in deck\r\n     */\r\n    startGame(deck: Array<Card>, shuffle: boolean, numRows: number, numDraw: number): void {\r\n\r\n        //Checks that the given deck is not null or invalid.\r\n        if (deck == null || !this.isValidDeck(deck)) {\r\n            throw new Error(\"The deck cannot be null.\");\r\n        }\r\n\r\n        // Checks if a pyramid of the given size and draw pile of the given size\r\n        // are possible with the size of the given deck.\r\n        if (!this.isEnoughCards(deck.length, numRows, numDraw)) {\r\n            throw new Error(\"Not enough cards in this deck for this deal.\");\r\n        }\r\n\r\n        // Checks if the number of rows or draws is 0, errors if so.\r\n        if (numRows == 0 && numDraw == 0) {\r\n            throw new Error(\"Rows and draws cannot be zero.\");\r\n        }\r\n\r\n        //Checks that the given number of rows is non-negative.\r\n        if (numRows <= 0) {\r\n            throw new Error(\"Number of rows cannot be negative or zero.\");\r\n        }\r\n\r\n        //Checks that the given number of draw cards is non-negative.\r\n        if (numDraw < 0) {\r\n            throw new Error(\"Number of draw cards cannot be negative.\");\r\n        }\r\n        // Copies the deck over to a temp so that it will not be altered.\r\n        let deckCopy: Array<Card> = new Array<Card>();\r\n\r\n        deck.forEach(function (value) {\r\n            deckCopy.push(value);\r\n        });\r\n\r\n        this.pyramid = this.dealCards(numRows, deckCopy, shuffle);\r\n        this.draws = new Array<Card>();\r\n        for (let drawIndex = 0; drawIndex < numDraw; drawIndex++) {\r\n            this.draws.push(deckCopy[0]);\r\n            deckCopy.shift();\r\n        }\r\n        this.stock = deckCopy;\r\n        this.gamestate = GameState.STARTED;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of lists of cards to represent the pyramid for the {@code BasicPyramidSolitaire}\r\n     * class.\r\n     *\r\n     * @param numRows the height of the pyramid to be created\r\n     * @param deck    the cards to be used for creating the pyramid\r\n     * @param shuffle indicates whether or not the user want's the deck to be shuffled\r\n     * @return a list of list of cards representing a pyramid for this game\r\n     */\r\n    protected abstract dealCards(numRows: number, deck: Array<Card>, shuffle: boolean): Array<Array<Card>>;\r\n\r\n\r\n\r\n    /**\r\n     * Execute a two-card move on the pyramid, using the two specified card positions.\r\n     *\r\n     * @param row1  row of first card position, numbered from 0 from the top of the pyramid\r\n     * @param card1 card of first card position, numbered from 0 from left\r\n     * @param row2  row of second card position\r\n     * @param card2 card of second card position\r\n     * @throws Error if the move is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    removeTwo(row1: number, card1: number, row2: number, card2: number) : void {\r\n        this.removeTwoChecks(row1, card1, row2, card2);\r\n\r\n        // Checks if the given cards are exposed.\r\n        if (this.isCovered(row1, card1) || this.isCovered(row2, card2)) {\r\n            throw new Error(\"The card at the given index is covered and therefore \"\r\n                + \"cannot be removed.\");\r\n        }\r\n        // Replaces the given cards with null\r\n        this.pyramid[row1][card1] = null;\r\n        this.pyramid[row2][card2] = null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute a single-card move on the pyramid, using the specified card position.\r\n     *\r\n     * @param row  row of the desired card position, numbered from 0 from the top of the pyramid\r\n     * @param card card of the desired card position, numbered from 0 from left\r\n     * @throws Error if the move is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    remove(row: number, card: number): void {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given row is in bounds from this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is in bounds from this game's pyramid.\r\n        if (!this.isCardInBounds(row, card)) {\r\n            throw new Error(\r\n                \"The given card index is out of bounds for the given row.\");\r\n        }\r\n        // Checks if the given card is null.\r\n        if (this.getCardAt(row, card) == null) {\r\n            throw new Error(\"No card at the given index. \");\r\n        }\r\n        // Checks if the given card has a value of the removal value.\r\n        if (this.getCardAt(row, card).getValue() != this.removalValue) {\r\n            throw new Error(\"The given card does not have a value of 13, \"\r\n                + \"and therefore cannot be removed.\");\r\n        }\r\n        // Checks if the given card is covered.\r\n        if (this.isCovered(row, card)) {\r\n            throw new Error(\"The card at the given index is covered and therefore \"\r\n                + \"cannot be removed.\");\r\n        }\r\n\r\n        // Sets the card at the given index to null.\r\n        this.pyramid[row][card] = null;\r\n    }\r\n\r\n    /**\r\n     * Execute a two-card move, using the specified card from the draw pile and the specified card\r\n     * from the pyramid.\r\n     *\r\n     * @param row  row of the desired card position, numbered from 0 from the top of the pyramid\r\n     * @param card card of the desired card position, numbered from 0 from left\r\n     * @throws Error if the move is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    removeUsingDraw(drawIndex: number, row: number, card: number): void {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given row is in bounds for this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is in bounds for this game's pyramid.\r\n        if (!this.isCardInBounds(row, card)) {\r\n            throw new Error(\r\n                \"The given card index is out of bounds for the given row.\");\r\n        }\r\n        // Checks if the given draw index is in bounds for the number of draw cards.\r\n        if (drawIndex >= this.draws.length || drawIndex < 0) {\r\n            throw new Error(\"The given draw index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is null.\r\n        if (this.getCardAt(row, card) == null) {\r\n            throw new Error(\"No card at the given index: \"+ row+ \", \" + card+\".\");\r\n        }\r\n        if (this.draws[drawIndex] == null) {\r\n            throw new Error(\"No card at the given index: \"+ drawIndex +\".\");\r\n        }\r\n        // Checks if the given draw card and pyramid card add up to the removal value.\r\n        if (this.getCardAt(row, card).getValue() + this.draws[drawIndex].getValue()\r\n            != this.removalValue) {\r\n            throw new Error(\"The given cards do not sum to a value of 13, \"\r\n                + \"and therefore cannot be removed.\");\r\n        }\r\n        // Checks if the given pyramid card is covered.\r\n        if (this.isCovered(row, card)) {\r\n            throw new Error(\"The card at the given index is covered and therefore \"\r\n                + \"cannot be removed.\");\r\n        }\r\n\r\n        // Sets pyramid card to null and discards the given draw card.\r\n        this.pyramid[row][card] = null;\r\n        this.discardDraw(drawIndex);\r\n    }\r\n\r\n    /**\r\n     * Discards an individual card from the draw pile.\r\n     *\r\n     * @param drawIndex the card to be discarded\r\n     * @throws Error if the index is invalid or no card is present there.\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    discardDraw(drawIndex: number): void {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given drawIndex is in bounds for the length of draws.\r\n        if (drawIndex < 0 || drawIndex >= this.draws.length) {\r\n            throw new Error(\"Index does not exist in the draw pile.\");\r\n        }\r\n        // Checks if there is a card at the given index.\r\n        if (this.draws[drawIndex] == null) { //should deal with 0 index 0 length\r\n            throw new Error(\"There is no card at this index.\");\r\n        }\r\n        // removes the given card\r\n        //delete this.draws[drawIndex];\r\n        // replaces the card absent in draws if there is one available\r\n        if (this.stock.length > 0) {\r\n            this.draws[drawIndex] = (this.stock[0])\r\n            this.stock.shift();\r\n        } else {\r\n            this.draws[drawIndex] = null;\r\n              //  this.draws.push(null);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns the number of rows originally in the pyramid, or -1 if the game hasn't been started.\r\n     *\r\n     * @return the height of the pyramid, or -1\r\n     */\r\n    getNumRows(): number {\r\n        // Checks if this game has started.\r\n        if (this.gamestate == GameState.NOT_STARTED) {\r\n            return -1;\r\n        }\r\n        // returns the height of this game's pyramid\r\n        return this.pyramid.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum number of visible cards in the draw pile, or -1 if the game hasn't been\r\n     * started.\r\n     *\r\n     * @return the number of visible cards in the draw pile, or -1\r\n     */\r\n    getNumDraw(): number {\r\n        // Checks if this game has started.\r\n        if (this.gamestate == GameState.NOT_STARTED) {\r\n            return -1;\r\n        }\r\n        // returns the length of this game's draws list\r\n        return this.draws.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the requested row, measured from the leftmost card to the rightmost card\r\n     * (inclusive) as the game is initially dealt.\r\n     *\r\n     * @param row the desired row (0-indexed)\r\n     * @return the number of spaces needed to deal out that row\r\n     * @throws Error if the row is invalid\r\n     * @throws Error if the game has not yet been started\r\n     */\r\n    getRowWidth(row: number): number {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the row is in bounds for this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row is out of bounds.\");\r\n        }\r\n        // returns the length of the given row\r\n        return this.pyramid[row].length;\r\n    }\r\n\r\n    /**\r\n     * Signal if the game is over or not.\r\n     *\r\n     * @return true if game is over, false otherwise\r\n     * @throws IllegalStateException if the game hasn't been started yet\r\n     */\r\n    isGameOver(): boolean {\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the game has been won.\r\n        if (this.isGameWon()) {\r\n            return true;\r\n        }\r\n\r\n        // checks if draws is empty\r\n        this.draws.forEach(function (value) {\r\n            if (value != null) {\r\n                return false;\r\n            }\r\n        });\r\n\r\n        let uncovered: Array<Card> = this.getUncovered();\r\n\r\n        // iterates over all the uncovered cards and checks\r\n        // if any of them evaluate to the removal value.\r\n        if (this.canBeRemoved(uncovered)) {\r\n            return false;\r\n        }\r\n\r\n        // iterates over all the uncovered cards and checks if any pair may add up to the removal value.\r\n        if (this.canAddToRemovalValue(uncovered)) {\r\n            return false;\r\n        }\r\n\r\n        //checks if there are cards in stock, and if we have draw space to access them.\r\n        return !(this.getNumDraw() > 0 && this.stock.length > 0);\r\n    }\r\n\r\n    /**\r\n     * Return the current score, which is the sum of the values of the cards remaining in the\r\n     * pyramid.\r\n     *\r\n     * @return the score\r\n     * @throws IllegalStateException if the game hasn't been started yet\r\n     */\r\n    getScore(): number {\r\n        // Checks if this game has started.\r\n        this.checkStarted();\r\n\r\n        if (this.isGameWon()) {\r\n            return 0;\r\n        }\r\n\r\n        // iterates through the results and adds up the values\r\n        let result: number = 0;\r\n        for (let row = 0 ; row < this.pyramid.length ; row++) {\r\n            for (let col = 0 ; col < this.pyramid[row].length; col++) {\r\n                if(this.pyramid[row][col] != null) {\r\n                    result = result + this.pyramid[row][col].getValue();\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the card at the specified coordinates.\r\n     *\r\n     * @param row  row of the desired card (0-indexed from the top)\r\n     * @param card column of the desired card (0-indexed from the left)\r\n     * @return the card at the given position, or <code>null</code> if no card is there\r\n     * @throws Error if the coordinates are invalid\r\n     * @throws Error if the game hasn't been started yet\r\n     */\r\n    getCardAt(row: number, card: number): Card {\r\n        // Checks if this game has started.\r\n        this.checkStarted();\r\n\r\n        // Checks if the given row is in bounds for this game's pyramid.\r\n        if (!this.isRowInBounds(row)) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card is in bounds for this game's pyramid.\r\n        if (!this.isCardInBounds(row, card)) {\r\n            throw new Error(\"The given card index is out of bounds.\");\r\n        }\r\n\r\n        // returns the card at the given index\r\n        return this.pyramid[row][card];\r\n    }\r\n\r\n    /**\r\n     * Returns the currently available draw cards. There should be at most {@link\r\n        * PyramidSolitaireModel#getNumDraw} cards (the number specified when the game started) -- there\r\n     * may be fewer, if cards have been removed.\r\n     *\r\n     * @return the ordered list of available draw cards\r\n     * @throws Error if the game hasn't been started yet\r\n     */\r\n    getDrawCards(): Array<Card> {\r\n        // Checks if the game has started.\r\n        this.checkStarted();\r\n\r\n        // Makes a copy of the draw cards list and returns it\r\n        let drawsCopy: Array<Card> = new Array<Card>();\r\n        this.draws.forEach(function(card){\r\n            drawsCopy.push(card);\r\n        });\r\n        return drawsCopy;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the card at the given row and card index is covered, meaning that it has\r\n     * non-null card values in the two spaces directly below the card itself.\r\n     *\r\n     * @param row  the row index of the card we are checking\r\n     * @param card the card index of the card we are checking\r\n     * @return whether the card at the given index is covered\r\n     */\r\n    protected isCovered(row: number, card: number): boolean {\r\n        // Checks if the given row index is in bounds for this game's pyramid.\r\n        if (row >= this.pyramid.length || row < 0) {\r\n            throw new Error(\"The given row index is out of bounds.\");\r\n        }\r\n        // Checks if the given card index is in bounds for this game's pyramid.\r\n        if (card >= this.pyramid[row].length || card < 0) {\r\n            throw new Error(\"The given card index is out of bounds\"\r\n                + \" for the given row.\");\r\n        }\r\n        // Checks if the card at the given index is in the bottom row.\r\n        if (row == this.pyramid.length - 1) {\r\n            return false;\r\n        } else {\r\n            // Checks if the cards directly below the card at the given index are null.\r\n            return this.getCardAt(row + 1, card) != null ||\r\n                this.getCardAt(row + 1, card + 1) != null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given deck is valid for this game of pyramid solitaire. Meaning that the\r\n     * given deck has no repeated cards, has no null cards, and is the same size as the valid deck\r\n     * produced by this class.\r\n     *\r\n     * @param deck the List of cards that we are checking for validity\r\n     * @return whether the given list is a valid deck for this game\r\n     */\r\n    protected abstract isValidDeck(deck: Array<Card>): boolean;\r\n\r\n    /**\r\n     * Returns whether this game is won, meaning there are no cards left in the pyramid, or rather\r\n     * that all cards in the pyramid are null.\r\n     *\r\n     * @return whether all of the cards in this game's pyramid are null.\r\n     */\r\n    protected isGameWon(): boolean {\r\n        // iterates over the cards in this game's pyramid and checks if any are not null\r\n\r\n        for (let row = 0 ; row < this.pyramid.length ; row++) {\r\n            for (let col = 0 ; col < this.pyramid[row].length; col++) {\r\n                if (this.pyramid[row][col] != null) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a deck of the given size could be used to deal a pyramid of the given number of\r\n     * rows, with the given number of draws.\r\n     *\r\n     * @param deckSize the size of the deck in question\r\n     * @param numRows  the number of rows in the pyramid in question\r\n     * @param numDraws the number of draws in the game in question\r\n     * @return if a deck of the given size has enough cards to deal\r\n     */\r\n    protected abstract isEnoughCards(deckSize: number, numRows: number, numDraws: number): boolean;\r\n\r\n    /**\r\n     * Returns whether the given row index is in bounds for this game's pyramid. Meaning, a row of the\r\n     * given index exists in the pyramid.\r\n     *\r\n     * @param row the row index\r\n     * @return whether the row is in bounds for this game's pyramid\r\n     */\r\n    protected isRowInBounds(row: number): boolean {\r\n        return row < this.pyramid.length && row >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the given card index is in bounds for the given row for this game's pyramid.\r\n     * Meaning, a row of the given index exists, and a card of the given index in the given row\r\n     * exists.\r\n     *\r\n     * @param row  the row index\r\n     * @param card the card index\r\n     * @return whether the card is within the bounds of this game's pyramid\r\n     */\r\n    protected isCardInBounds(row: number, card: number): boolean {\r\n        return this.isRowInBounds(row) && card < this.pyramid[row].length && card >= 0;\r\n    }\r\n\r\n    /**\r\n     * Returns whether any of the cards in the given list can be removed by themselves, assuming all\r\n     * the given cards are uncovered (can be removed) and that in order to be removed the card value\r\n     * must match the removal value.\r\n     *\r\n     * @param cards the list of cards being checked\r\n     * @return whether the given list of cards contains cards which can be removed\r\n     */\r\n    private canBeRemoved(cards: Array<Card>): boolean {\r\n        // iterates over all of the cards in the given list and\r\n        // checks if they have a value equal to the removal value\r\n\r\n        for (let index = 0; index < cards.length ; index++) {\r\n            if (cards[index].getValue() == this.removalValue) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether any two cards in the given list of cards can sum to the removal value of this\r\n     * game.\r\n     *\r\n     * @param cards list of cards to be checked\r\n     * @return whether there exists in the list a pair of cars that sum to the removal value\r\n     */\r\n    private canAddToRemovalValue(cards: Array<Card>): boolean {\r\n        // iterates over every possible pairing of cards in the given list of cards\r\n        for (let card1 = 0; card1 < cards.length; card1 += 1) {\r\n            for (let card2 = 0; card2 < cards.length; card2 += 1) {\r\n                if (card1 != card2 &&\r\n                    cards[card1].getValue() + cards[card2].getValue() == this.removalValue) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the uncovered cards in this game's pyramid, meaning all of the cards that do\r\n     * not have two cards directly below them in the pyramid.\r\n     *\r\n     * @return list of all uncovered cards in this game's pyramid\r\n     */\r\n    private getUncovered(): Array<Card> {\r\n        let uncovered: Array<Card> = new Array<Card>();\r\n        // iterates over all of the cards in the pyramid and adds the uncovered ones\r\n        for (let row = 0; row < this.pyramid.length; row += 1) {\r\n            for (let card = 0; card < this.pyramid[row].length; card += 1) {\r\n                if (this.getCardAt(row, card) != null && !this.isCovered(row, card)) {\r\n                    uncovered.push(this.getCardAt(row, card));\r\n                }\r\n            }\r\n        }\r\n        return uncovered;\r\n    }\r\n\r\n    /**\r\n     * Checks if this game has been started, if not, throws an IllegalStateException.\r\n     *\r\n     * @throws IllegalStateException when game has not been started\r\n     */\r\n    protected checkStarted(): void {\r\n        if (this.gamestate == GameState.NOT_STARTED) {\r\n            throw new Error(\"The game has not yet started.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the draw pile of this game has only null cards, meaning all draw cards have been\r\n     * discarded.\r\n     *\r\n     * @return whether all cards in this game's draws are discarded (null)\r\n     */\r\n    protected allDiscarded(): boolean {\r\n        this.draws.forEach(function (card) {\r\n            if (card != null) {\r\n                return false;\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the removal of the cards with the given indexes is possible, errors if not.\r\n     */\r\n    protected removeTwoChecks(row1: number, card1: number, row2: number, card2: number): void{\r\n        // Checks if this game has been started.\r\n        this.checkStarted();\r\n        // Checks if the given rows are within the bounds of this game's pyramid.\r\n        if (!this.isRowInBounds(row1) || !this.isRowInBounds(row2)) {\r\n            throw new Error(\"The given row is out of bounds.\");\r\n        }\r\n        // Checks if the given cards are within the bounds of the game's pyramid.\r\n        if (!this.isCardInBounds(row1, card1) || !this.isCardInBounds(row2, card2)) {\r\n            throw new Error(\"The given card is out of bounds for the given row.\");\r\n        }\r\n        // Checks if either of the given cards is null.\r\n        if (this.getCardAt(row1, card1) == null) {\r\n            throw new Error(\"No card at the given index, \" + row1 + \", \" + card1 + \".\");\r\n        }\r\n\r\n        if (this.getCardAt(row2, card2) == null) {\r\n            throw new Error(\"No card at the given index, \" + row2 + \", \" + card2 + \".\");\r\n        }\r\n\r\n\r\n        // Checks if the cards at the given indexes add up to the removal value.\r\n        if (this.getCardAt(row1, card1).getValue() + this.getCardAt(row2, card2).getValue()\r\n            != this.removalValue) {\r\n            throw new Error(\"The given cards do not add up to 13, and \"\r\n                + \"therefore cannot be removed.\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\Suit.ts",[],"C:\\Users\\davis\\WebstormProjects\\web-solitaire-react\\src\\GameState.ts",[],{"ruleId":"109","replacedBy":"110"},{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","severity":1,"message":"114","line":2,"column":8,"nodeType":"115","messageId":"116","endLine":2,"endColumn":12},{"ruleId":"117","severity":1,"message":"118","line":20,"column":5,"nodeType":"119","messageId":"120","endLine":23,"endColumn":6},{"ruleId":"121","severity":1,"message":"122","line":28,"column":23,"nodeType":"123","messageId":"124","endLine":28,"endColumn":49},{"ruleId":"121","severity":1,"message":"122","line":30,"column":44,"nodeType":"123","messageId":"124","endLine":30,"endColumn":70},{"ruleId":"125","severity":1,"message":"126","line":69,"column":24,"nodeType":"127","messageId":"128","endLine":69,"endColumn":26},{"ruleId":"121","severity":1,"message":"129","line":153,"column":31,"nodeType":"123","messageId":"124","endLine":153,"endColumn":46},{"ruleId":"121","severity":1,"message":"129","line":274,"column":21,"nodeType":"123","messageId":"124","endLine":274,"endColumn":44},{"ruleId":"125","severity":1,"message":"126","line":310,"column":41,"nodeType":"127","messageId":"128","endLine":310,"endColumn":43},{"ruleId":"125","severity":1,"message":"126","line":73,"column":38,"nodeType":"127","messageId":"128","endLine":73,"endColumn":40},{"ruleId":"121","severity":1,"message":"129","line":115,"column":74,"nodeType":"123","messageId":"124","endLine":115,"endColumn":87},{"ruleId":"121","severity":1,"message":"129","line":128,"column":41,"nodeType":"123","messageId":"124","endLine":128,"endColumn":54},{"ruleId":"125","severity":1,"message":"126","line":150,"column":41,"nodeType":"127","messageId":"128","endLine":150,"endColumn":43},{"ruleId":"125","severity":1,"message":"126","line":167,"column":41,"nodeType":"127","messageId":"128","endLine":167,"endColumn":43},{"ruleId":"125","severity":1,"message":"126","line":216,"column":34,"nodeType":"127","messageId":"128","endLine":216,"endColumn":36},{"ruleId":"121","severity":1,"message":"129","line":52,"column":34,"nodeType":"123","messageId":"124","endLine":52,"endColumn":52},{"ruleId":"121","severity":1,"message":"129","line":69,"column":34,"nodeType":"123","messageId":"124","endLine":69,"endColumn":52},{"ruleId":"125","severity":1,"message":"126","line":140,"column":66,"nodeType":"127","messageId":"128","endLine":140,"endColumn":68},{"ruleId":"125","severity":1,"message":"126","line":141,"column":62,"nodeType":"127","messageId":"128","endLine":141,"endColumn":64},{"ruleId":"125","severity":1,"message":"130","line":65,"column":27,"nodeType":"127","messageId":"128","endLine":65,"endColumn":29},{"ruleId":"125","severity":1,"message":"126","line":76,"column":28,"nodeType":"127","messageId":"128","endLine":76,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":43,"column":18,"nodeType":"127","messageId":"128","endLine":43,"endColumn":20},{"ruleId":"121","severity":1,"message":"131","line":49,"column":27,"nodeType":"123","messageId":"124","endLine":49,"endColumn":38},{"ruleId":"125","severity":1,"message":"126","line":50,"column":23,"nodeType":"127","messageId":"128","endLine":50,"endColumn":25},{"ruleId":"125","severity":1,"message":"126","line":51,"column":23,"nodeType":"127","messageId":"128","endLine":51,"endColumn":25},{"ruleId":"125","severity":1,"message":"126","line":36,"column":18,"nodeType":"127","messageId":"128","endLine":36,"endColumn":20},{"ruleId":"121","severity":1,"message":"132","line":42,"column":27,"nodeType":"123","messageId":"124","endLine":42,"endColumn":37},{"ruleId":"125","severity":1,"message":"126","line":43,"column":27,"nodeType":"127","messageId":"128","endLine":43,"endColumn":29},{"ruleId":"125","severity":1,"message":"126","line":44,"column":23,"nodeType":"127","messageId":"128","endLine":44,"endColumn":25},{"ruleId":"125","severity":1,"message":"126","line":48,"column":24,"nodeType":"127","messageId":"128","endLine":48,"endColumn":26},{"ruleId":"125","severity":1,"message":"126","line":50,"column":31,"nodeType":"127","messageId":"128","endLine":50,"endColumn":33},{"ruleId":"125","severity":1,"message":"126","line":52,"column":31,"nodeType":"127","messageId":"128","endLine":52,"endColumn":33},{"ruleId":"125","severity":1,"message":"126","line":54,"column":31,"nodeType":"127","messageId":"128","endLine":54,"endColumn":33},{"ruleId":"125","severity":1,"message":"126","line":67,"column":21,"nodeType":"127","messageId":"128","endLine":67,"endColumn":23},{"ruleId":"125","severity":1,"message":"126","line":67,"column":37,"nodeType":"127","messageId":"128","endLine":67,"endColumn":39},{"ruleId":"125","severity":1,"message":"130","line":160,"column":50,"nodeType":"127","messageId":"128","endLine":160,"endColumn":52},{"ruleId":"125","severity":1,"message":"130","line":209,"column":13,"nodeType":"127","messageId":"128","endLine":209,"endColumn":15},{"ruleId":"125","severity":1,"message":"126","line":263,"column":28,"nodeType":"127","messageId":"128","endLine":263,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":278,"column":28,"nodeType":"127","messageId":"128","endLine":278,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":437,"column":17,"nodeType":"127","messageId":"128","endLine":437,"endColumn":19},{"ruleId":"125","severity":1,"message":"126","line":523,"column":41,"nodeType":"127","messageId":"128","endLine":523,"endColumn":43},{"ruleId":"125","severity":1,"message":"130","line":541,"column":27,"nodeType":"127","messageId":"128","endLine":541,"endColumn":29},{"ruleId":"125","severity":1,"message":"126","line":542,"column":71,"nodeType":"127","messageId":"128","endLine":542,"endColumn":73},{"ruleId":"125","severity":1,"message":"126","line":575,"column":28,"nodeType":"127","messageId":"128","endLine":575,"endColumn":30},{"ruleId":"125","severity":1,"message":"130","line":621,"column":13,"nodeType":"127","messageId":"128","endLine":621,"endColumn":15},"no-native-reassign",["133"],"no-negated-in-lhs",["134"],"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","@typescript-eslint/consistent-type-assertions","Use 'as HTMLCanvasElement' instead of '<HTMLCanvasElement>'.","TSTypeAssertion","as","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Use 'as string' instead of '<string>'.","Expected '!==' and instead saw '!='.","Use 'as Pos2D' instead of '<Pos2D>'.","Use 'as Card' instead of '<Card>'.","no-global-assign","no-unsafe-negation"]